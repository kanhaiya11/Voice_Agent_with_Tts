{"version":3,"sources":["../../src/llm/tool_context.type.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { describe, expect, expectTypeOf, it } from 'vitest';\nimport { z } from 'zod';\nimport { type FunctionTool, type ProviderDefinedTool, type ToolOptions, tool } from './index.js';\n\ndescribe('tool type inference', () => {\n  it('should infer argument type from zod schema', () => {\n    const toolType = tool({\n      description: 'test',\n      parameters: z.object({ number: z.number() }),\n      execute: async () => 'test' as const,\n    });\n\n    expectTypeOf(toolType).toEqualTypeOf<FunctionTool<{ number: number }, unknown, 'test'>>();\n  });\n\n  it('should infer provider defined tool type', () => {\n    const toolType = tool({\n      id: 'code-interpreter',\n      config: {\n        language: 'python',\n      },\n    });\n\n    expectTypeOf(toolType).toEqualTypeOf<ProviderDefinedTool>();\n  });\n\n  it('should infer run context type', () => {\n    const toolType = tool({\n      description: 'test',\n      parameters: z.object({ number: z.number() }),\n      execute: async ({ number }, { ctx }: ToolOptions<{ name: string }>) => {\n        return `The number is ${number}, ${ctx.userData.name}`;\n      },\n    });\n\n    expectTypeOf(toolType).toEqualTypeOf<\n      FunctionTool<{ number: number }, { name: string }, string>\n    >();\n  });\n\n  it('should not accept primitive zod schemas', () => {\n    expect(() => {\n      // @ts-expect-error - Testing that non-object schemas are rejected\n      tool({\n        name: 'test',\n        description: 'test',\n        parameters: z.string(),\n        execute: async () => 'test' as const,\n      });\n    }).toThrowError('Tool parameters must be a Zod object schema (z.object(...))');\n  });\n\n  it('should not accept array schemas', () => {\n    expect(() => {\n      // @ts-expect-error - Testing that array schemas are rejected\n      tool({\n        name: 'test',\n        description: 'test',\n        parameters: z.array(z.string()),\n        execute: async () => 'test' as const,\n      });\n    }).toThrowError('Tool parameters must be a Zod object schema (z.object(...))');\n  });\n\n  it('should not accept union schemas', () => {\n    expect(() => {\n      // @ts-expect-error - Testing that union schemas are rejected\n      tool({\n        name: 'test',\n        description: 'test',\n        parameters: z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]),\n        execute: async () => 'test' as const,\n      });\n    }).toThrowError('Tool parameters must be a Zod object schema (z.object(...))');\n  });\n\n  it('should not accept non-Zod values as parameters', () => {\n    expect(() => {\n      // @ts-expect-error - Testing that non-Zod values are rejected\n      tool({\n        name: 'test',\n        description: 'test',\n        parameters: 'invalid schema',\n        execute: async () => 'test' as const,\n      });\n    }).toThrowError('Tool parameters must be a Zod object schema or a raw JSON schema');\n  });\n\n  it('should infer empty object type when parameters are omitted', () => {\n    const toolType = tool({\n      description: 'Simple action without parameters',\n      execute: async () => 'done' as const,\n    });\n\n    expectTypeOf(toolType).toEqualTypeOf<FunctionTool<Record<string, never>, unknown, 'done'>>();\n  });\n\n  it('should infer correct types with context but no parameters', () => {\n    const toolType = tool({\n      description: 'Action with context',\n      execute: async (args, { ctx }: ToolOptions<{ userId: number }>) => {\n        expectTypeOf(args).toEqualTypeOf<Record<string, never>>();\n        expectTypeOf(ctx.userData.userId).toEqualTypeOf<number>();\n        return ctx.userData.userId;\n      },\n    });\n\n    expectTypeOf(toolType).toEqualTypeOf<\n      FunctionTool<Record<string, never>, { userId: number }, number>\n    >();\n  });\n});\n"],"mappings":"AAGA,SAAS,UAAU,QAAQ,cAAc,UAAU;AACnD,SAAS,SAAS;AAClB,SAAwE,YAAY;AAEpF,SAAS,uBAAuB,MAAM;AACpC,KAAG,8CAA8C,MAAM;AACrD,UAAM,WAAW,KAAK;AAAA,MACpB,aAAa;AAAA,MACb,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;AAAA,MAC3C,SAAS,YAAY;AAAA,IACvB,CAAC;AAED,iBAAa,QAAQ,EAAE,cAAiE;AAAA,EAC1F,CAAC;AAED,KAAG,2CAA2C,MAAM;AAClD,UAAM,WAAW,KAAK;AAAA,MACpB,IAAI;AAAA,MACJ,QAAQ;AAAA,QACN,UAAU;AAAA,MACZ;AAAA,IACF,CAAC;AAED,iBAAa,QAAQ,EAAE,cAAmC;AAAA,EAC5D,CAAC;AAED,KAAG,iCAAiC,MAAM;AACxC,UAAM,WAAW,KAAK;AAAA,MACpB,aAAa;AAAA,MACb,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;AAAA,MAC3C,SAAS,OAAO,EAAE,OAAO,GAAG,EAAE,IAAI,MAAqC;AACrE,eAAO,iBAAiB,MAAM,KAAK,IAAI,SAAS,IAAI;AAAA,MACtD;AAAA,IACF,CAAC;AAED,iBAAa,QAAQ,EAAE,cAErB;AAAA,EACJ,CAAC;AAED,KAAG,2CAA2C,MAAM;AAClD,WAAO,MAAM;AAEX,WAAK;AAAA,QACH,MAAM;AAAA,QACN,aAAa;AAAA,QACb,YAAY,EAAE,OAAO;AAAA,QACrB,SAAS,YAAY;AAAA,MACvB,CAAC;AAAA,IACH,CAAC,EAAE,aAAa,6DAA6D;AAAA,EAC/E,CAAC;AAED,KAAG,mCAAmC,MAAM;AAC1C,WAAO,MAAM;AAEX,WAAK;AAAA,QACH,MAAM;AAAA,QACN,aAAa;AAAA,QACb,YAAY,EAAE,MAAM,EAAE,OAAO,CAAC;AAAA,QAC9B,SAAS,YAAY;AAAA,MACvB,CAAC;AAAA,IACH,CAAC,EAAE,aAAa,6DAA6D;AAAA,EAC/E,CAAC;AAED,KAAG,mCAAmC,MAAM;AAC1C,WAAO,MAAM;AAEX,WAAK;AAAA,QACH,MAAM;AAAA,QACN,aAAa;AAAA,QACb,YAAY,EAAE,MAAM,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;AAAA,QAC9E,SAAS,YAAY;AAAA,MACvB,CAAC;AAAA,IACH,CAAC,EAAE,aAAa,6DAA6D;AAAA,EAC/E,CAAC;AAED,KAAG,kDAAkD,MAAM;AACzD,WAAO,MAAM;AAEX,WAAK;AAAA,QACH,MAAM;AAAA,QACN,aAAa;AAAA,QACb,YAAY;AAAA,QACZ,SAAS,YAAY;AAAA,MACvB,CAAC;AAAA,IACH,CAAC,EAAE,aAAa,kEAAkE;AAAA,EACpF,CAAC;AAED,KAAG,8DAA8D,MAAM;AACrE,UAAM,WAAW,KAAK;AAAA,MACpB,aAAa;AAAA,MACb,SAAS,YAAY;AAAA,IACvB,CAAC;AAED,iBAAa,QAAQ,EAAE,cAAoE;AAAA,EAC7F,CAAC;AAED,KAAG,6DAA6D,MAAM;AACpE,UAAM,WAAW,KAAK;AAAA,MACpB,aAAa;AAAA,MACb,SAAS,OAAO,MAAM,EAAE,IAAI,MAAuC;AACjE,qBAAa,IAAI,EAAE,cAAqC;AACxD,qBAAa,IAAI,SAAS,MAAM,EAAE,cAAsB;AACxD,eAAO,IAAI,SAAS;AAAA,MACtB;AAAA,IACF,CAAC;AAED,iBAAa,QAAQ,EAAE,cAErB;AAAA,EACJ,CAAC;AACH,CAAC;","names":[]}
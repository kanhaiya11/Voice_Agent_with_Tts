{"version":3,"sources":["../../src/llm/utils.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { VideoBufferType, VideoFrame } from '@livekit/rtc-node';\nimport type { JSONSchema7 } from 'json-schema';\nimport sharp from 'sharp';\nimport { ZodObject } from 'zod';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport type { UnknownUserData } from '../voice/run_context.js';\nimport type { ChatContext } from './chat_context.js';\nimport {\n  type ChatItem,\n  FunctionCall,\n  FunctionCallOutput,\n  type ImageContent,\n} from './chat_context.js';\nimport type { ToolContext, ToolInputSchema, ToolOptions } from './tool_context.js';\n\nexport interface SerializedImage {\n  inferenceDetail: 'auto' | 'high' | 'low';\n  mimeType?: string;\n  base64Data?: string;\n  externalUrl?: string;\n}\n\nfunction getChannelsFromVideoBufferType(type: VideoBufferType): 3 | 4 {\n  switch (type) {\n    case VideoBufferType.RGBA:\n    case VideoBufferType.ABGR:\n    case VideoBufferType.ARGB:\n    case VideoBufferType.BGRA:\n      return 4;\n    case VideoBufferType.RGB24:\n      return 3;\n    default:\n      // YUV formats (I420, I420A, I422, I444, I010, NV12) need conversion\n      throw new Error(`Unsupported VideoBufferType: ${type}. Only RGB/RGBA formats are supported.`);\n  }\n}\n\nfunction ensureRGBCompatible(frame: VideoFrame): VideoFrame {\n  // If the frame is already in an RGB/RGBA-compatible format, return it directly\n  if (\n    frame.type === VideoBufferType.RGBA ||\n    frame.type === VideoBufferType.BGRA ||\n    frame.type === VideoBufferType.ARGB ||\n    frame.type === VideoBufferType.ABGR ||\n    frame.type === VideoBufferType.RGB24\n  ) {\n    return frame;\n  }\n\n  // Otherwise, attempt conversion for other formats (like YUV)\n  try {\n    return frame.convert(VideoBufferType.RGBA);\n  } catch (error) {\n    throw new Error(\n      `Failed to convert format ${frame.type} to RGB: ${error}. ` +\n        `Consider using RGB/RGBA formats or converting on the client side.`,\n    );\n  }\n}\n\nexport async function serializeImage(image: ImageContent): Promise<SerializedImage> {\n  if (typeof image.image === 'string') {\n    if (image.image.startsWith('data:')) {\n      const [header, base64Data] = image.image.split(',', 2) as [string, string];\n      const headerParts = header.split(';');\n      const mimeParts = headerParts[0]?.split(':');\n      const headerMime = mimeParts?.[1];\n\n      if (!headerMime) {\n        throw new Error('Invalid data URL format');\n      }\n\n      let mimeType: string;\n      if (image.mimeType && image.mimeType !== headerMime) {\n        console.warn(\n          `Provided mimeType '${image.mimeType}' does not match data URL mime type '${headerMime}'. Using provided mimeType.`,\n        );\n        mimeType = image.mimeType;\n      } else {\n        mimeType = headerMime;\n      }\n\n      const supportedTypes = new Set(['image/jpeg', 'image/png', 'image/webp', 'image/gif']);\n      if (!supportedTypes.has(mimeType)) {\n        throw new Error(`Unsupported mimeType ${mimeType}. Must be jpeg, png, webp, or gif`);\n      }\n\n      return {\n        base64Data,\n        mimeType: mimeType,\n        inferenceDetail: image.inferenceDetail,\n      };\n    }\n\n    // External URL\n    return {\n      mimeType: image.mimeType,\n      inferenceDetail: image.inferenceDetail,\n      externalUrl: image.image,\n    };\n  } else if (image.image instanceof VideoFrame) {\n    const frame = ensureRGBCompatible(image.image);\n    const channels = getChannelsFromVideoBufferType(frame.type);\n\n    // Sharp needs to know the format of raw pixel data\n    let encoded = sharp(frame.data, {\n      raw: {\n        width: frame.width,\n        height: frame.height,\n        channels,\n      },\n    });\n\n    if (image.inferenceWidth && image.inferenceHeight) {\n      encoded = encoded.resize(image.inferenceWidth, image.inferenceHeight);\n    }\n\n    const base64Data = await encoded\n      .png()\n      .toBuffer()\n      .then((buffer) => buffer.toString('base64'));\n\n    return {\n      base64Data,\n      mimeType: 'image/png',\n      inferenceDetail: image.inferenceDetail,\n    };\n  } else {\n    throw new Error('Unsupported image type');\n  }\n}\n\n/** Raw OpenAI-adherent function parameters. */\nexport type OpenAIFunctionParameters = {\n  type: 'object';\n  properties: { [id: string]: any }; // eslint-disable-line @typescript-eslint/no-explicit-any\n  required: string[];\n  additionalProperties?: boolean;\n};\n\n// TODO(brian): remove this helper once we have the real RunContext user data\nexport const createToolOptions = <UserData extends UnknownUserData>(\n  toolCallId: string,\n  userData: UserData = {} as UserData,\n): ToolOptions<UserData> => {\n  return { ctx: { userData }, toolCallId } as unknown as ToolOptions<UserData>;\n};\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const oaiParams = (\n  p: ZodObject<any>,\n  isOpenai: boolean = true,\n): OpenAIFunctionParameters => {\n  // Adapted from https://github.com/vercel/ai/blob/56eb0ee9/packages/provider-utils/src/zod-schema.ts\n  const { properties, required, additionalProperties } = zodToJsonSchema(p, {\n    // note: openai mode breaks various gemini conversions\n    target: isOpenai ? 'openAi' : 'jsonSchema7',\n  }) as OpenAIFunctionParameters;\n\n  return {\n    type: 'object',\n    properties,\n    required,\n    additionalProperties,\n  };\n};\n\n/** @internal */\nexport const oaiBuildFunctionInfo = (\n  toolCtx: ToolContext,\n  toolCallId: string,\n  toolName: string,\n  rawArgs: string,\n): FunctionCall => {\n  const tool = toolCtx[toolName];\n  if (!tool) {\n    throw new Error(`AI tool ${toolName} not found`);\n  }\n\n  return FunctionCall.create({\n    callId: toolCallId,\n    name: toolName,\n    args: rawArgs,\n  });\n};\n\nexport async function executeToolCall(\n  toolCall: FunctionCall,\n  toolCtx: ToolContext,\n): Promise<FunctionCallOutput> {\n  const tool = toolCtx[toolCall.name]!;\n  let args: object | undefined;\n  let params: object | undefined;\n\n  // Ensure valid JSON\n  try {\n    args = JSON.parse(toolCall.args);\n  } catch (error) {\n    return FunctionCallOutput.create({\n      callId: toolCall.callId,\n      output: `Invalid JSON: ${error}`,\n      isError: true,\n    });\n  }\n\n  // Ensure valid arguments schema\n  try {\n    if (tool.parameters instanceof ZodObject) {\n      params = tool.parameters.parse(args);\n    } else {\n      params = args;\n    }\n  } catch (error) {\n    return FunctionCallOutput.create({\n      callId: toolCall.callId,\n      output: `Arguments parsing failed: ${error}`,\n      isError: true,\n    });\n  }\n\n  try {\n    const result = await tool.execute(params, createToolOptions(toolCall.callId));\n    return FunctionCallOutput.create({\n      callId: toolCall.callId,\n      output: JSON.stringify(result),\n      isError: false,\n    });\n  } catch (error) {\n    return FunctionCallOutput.create({\n      callId: toolCall.callId,\n      output: `Tool execution failed: ${error}`,\n      isError: true,\n    });\n  }\n}\n\n/**\n * Standard dynamic-programming LCS to get the common subsequence\n * of IDs (in order) that appear in both old_ids and new_ids.\n *\n * @param oldIds - The old list of IDs.\n * @param newIds - The new list of IDs.\n * @returns The longest common subsequence of the two lists of IDs.\n */\nfunction computeLCS(oldIds: string[], newIds: string[]): string[] {\n  const n = oldIds.length;\n  const m = newIds.length;\n  const dp: number[][] = Array(n + 1)\n    .fill(null)\n    .map(() => Array(m + 1).fill(0));\n\n  // Fill DP table\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (oldIds[i - 1] === newIds[j - 1]) {\n        dp[i]![j] = dp[i - 1]![j - 1]! + 1;\n      } else {\n        dp[i]![j] = Math.max(dp[i - 1]![j]!, dp[i]![j - 1]!);\n      }\n    }\n  }\n\n  // Backtrack to find the actual LCS sequence\n  const lcsIds: string[] = [];\n  let i = n;\n  let j = m;\n  while (i > 0 && j > 0) {\n    if (oldIds[i - 1] === newIds[j - 1]) {\n      lcsIds.push(oldIds[i - 1]!);\n      i--;\n      j--;\n    } else if (dp[i - 1]![j]! > dp[i]![j - 1]!) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n\n  return lcsIds.reverse();\n}\n\ninterface DiffOps {\n  toRemove: string[];\n  toCreate: Array<[string | null, string]>; // (previous_item_id, id), if previous_item_id is null, add to the root\n}\n\n/**\n * Compute the minimal list of create/remove operations to transform oldCtx into newCtx.\n *\n * @param oldCtx - The old chat context.\n * @param newCtx - The new chat context.\n * @returns The minimal list of create/remove operations to transform oldCtx into newCtx.\n */\nexport function computeChatCtxDiff(oldCtx: ChatContext, newCtx: ChatContext): DiffOps {\n  const oldIds = oldCtx.items.map((item: ChatItem) => item.id);\n  const newIds = newCtx.items.map((item: ChatItem) => item.id);\n  const lcsIds = new Set(computeLCS(oldIds, newIds));\n\n  const toRemove = oldCtx.items.filter((msg) => !lcsIds.has(msg.id)).map((msg) => msg.id);\n  const toCreate: Array<[string | null, string]> = [];\n\n  let lastIdInSequence: string | null = null;\n  for (const newItem of newCtx.items) {\n    if (lcsIds.has(newItem.id)) {\n      lastIdInSequence = newItem.id;\n    } else {\n      const prevId = lastIdInSequence; // null if root\n      toCreate.push([prevId, newItem.id]);\n      lastIdInSequence = newItem.id;\n    }\n  }\n\n  return {\n    toRemove,\n    toCreate,\n  };\n}\n\nexport function toJsonSchema(schema: ToolInputSchema<any>, isOpenai: boolean = true): JSONSchema7 {\n  if (schema instanceof ZodObject) {\n    return oaiParams(schema, isOpenai);\n  }\n  return schema;\n}\n"],"mappings":"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","names":["i","j"]}
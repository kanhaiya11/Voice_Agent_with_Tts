{"version":3,"sources":["../../../src/llm/provider_format/openai.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { ChatContext, ChatItem, ImageContent } from '../chat_context.js';\nimport { type SerializedImage, serializeImage } from '../utils.js';\nimport { groupToolCalls } from './utils.js';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function toChatCtx(chatCtx: ChatContext, injectDummyUserMessage: boolean = true) {\n  const itemGroups = groupToolCalls(chatCtx);\n  const messages: Record<string, any>[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  for (const group of itemGroups) {\n    if (group.isEmpty) continue;\n\n    const message: Record<string, any> = group.message // eslint-disable-line @typescript-eslint/no-explicit-any\n      ? await toChatItem(group.message)\n      : { role: 'assistant' };\n\n    const toolCalls = group.toolCalls.map((toolCall) => ({\n      type: 'function',\n      id: toolCall.callId,\n      function: { name: toolCall.name, arguments: toolCall.args },\n    }));\n\n    if (toolCalls.length > 0) {\n      message['tool_calls'] = toolCalls;\n    }\n\n    messages.push(message);\n\n    for (const toolOutput of group.toolOutputs) {\n      messages.push(await toChatItem(toolOutput));\n    }\n  }\n\n  return messages;\n}\n\nasync function toChatItem(item: ChatItem) {\n  if (item.type === 'message') {\n    const listContent: Record<string, any>[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n    let textContent = '';\n\n    for (const content of item.content) {\n      if (typeof content === 'string') {\n        if (textContent) textContent += '\\n';\n        textContent += content;\n      } else if (content.type === 'image_content') {\n        listContent.push(await toImageContent(content));\n      } else {\n        throw new Error(`Unsupported content type: ${content.type}`);\n      }\n    }\n\n    const content =\n      listContent.length == 0\n        ? textContent\n        : textContent.length == 0\n          ? listContent\n          : [...listContent, { type: 'text', text: textContent }];\n\n    return { role: item.role, content };\n  } else if (item.type === 'function_call') {\n    return {\n      role: 'assistant',\n      tool_calls: [\n        {\n          id: item.callId,\n          type: 'function',\n          function: { name: item.name, arguments: item.args },\n        },\n      ],\n    };\n  } else if (item.type === 'function_call_output') {\n    return {\n      role: 'tool',\n      tool_call_id: item.callId,\n      content: item.output,\n    };\n  } else {\n    throw new Error(`Unsupported item type: ${item['type']}`);\n  }\n}\n\nasync function toImageContent(content: ImageContent) {\n  const cacheKey = 'serialized_image'; // TODO: use hash of encoding options if available\n  let serialized: SerializedImage;\n\n  if (content._cache[cacheKey] === undefined) {\n    serialized = await serializeImage(content);\n    content._cache[cacheKey] = serialized;\n  }\n  serialized = content._cache[cacheKey];\n\n  // Convert SerializedImage to OpenAI format\n  if (serialized.externalUrl) {\n    return {\n      type: 'image_url',\n      image_url: {\n        url: serialized.externalUrl,\n        detail: serialized.inferenceDetail,\n      },\n    };\n  }\n\n  if (serialized.base64Data === undefined) {\n    throw new Error('Serialized image has no data bytes');\n  }\n\n  return {\n    type: 'image_url',\n    image_url: {\n      url: `data:${serialized.mimeType};base64,${serialized.base64Data}`,\n      detail: serialized.inferenceDetail,\n    },\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,mBAAqD;AACrD,IAAAA,gBAA+B;AAG/B,eAAsB,UAAU,SAAsB,yBAAkC,MAAM;AAC5F,QAAM,iBAAa,8BAAe,OAAO;AACzC,QAAM,WAAkC,CAAC;AAEzC,aAAW,SAAS,YAAY;AAC9B,QAAI,MAAM,QAAS;AAEnB,UAAM,UAA+B,MAAM,UACvC,MAAM,WAAW,MAAM,OAAO,IAC9B,EAAE,MAAM,YAAY;AAExB,UAAM,YAAY,MAAM,UAAU,IAAI,CAAC,cAAc;AAAA,MACnD,MAAM;AAAA,MACN,IAAI,SAAS;AAAA,MACb,UAAU,EAAE,MAAM,SAAS,MAAM,WAAW,SAAS,KAAK;AAAA,IAC5D,EAAE;AAEF,QAAI,UAAU,SAAS,GAAG;AACxB,cAAQ,YAAY,IAAI;AAAA,IAC1B;AAEA,aAAS,KAAK,OAAO;AAErB,eAAW,cAAc,MAAM,aAAa;AAC1C,eAAS,KAAK,MAAM,WAAW,UAAU,CAAC;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AACT;AAEA,eAAe,WAAW,MAAgB;AACxC,MAAI,KAAK,SAAS,WAAW;AAC3B,UAAM,cAAqC,CAAC;AAC5C,QAAI,cAAc;AAElB,eAAWC,YAAW,KAAK,SAAS;AAClC,UAAI,OAAOA,aAAY,UAAU;AAC/B,YAAI,YAAa,gBAAe;AAChC,uBAAeA;AAAA,MACjB,WAAWA,SAAQ,SAAS,iBAAiB;AAC3C,oBAAY,KAAK,MAAM,eAAeA,QAAO,CAAC;AAAA,MAChD,OAAO;AACL,cAAM,IAAI,MAAM,6BAA6BA,SAAQ,IAAI,EAAE;AAAA,MAC7D;AAAA,IACF;AAEA,UAAM,UACJ,YAAY,UAAU,IAClB,cACA,YAAY,UAAU,IACpB,cACA,CAAC,GAAG,aAAa,EAAE,MAAM,QAAQ,MAAM,YAAY,CAAC;AAE5D,WAAO,EAAE,MAAM,KAAK,MAAM,QAAQ;AAAA,EACpC,WAAW,KAAK,SAAS,iBAAiB;AACxC,WAAO;AAAA,MACL,MAAM;AAAA,MACN,YAAY;AAAA,QACV;AAAA,UACE,IAAI,KAAK;AAAA,UACT,MAAM;AAAA,UACN,UAAU,EAAE,MAAM,KAAK,MAAM,WAAW,KAAK,KAAK;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAAA,EACF,WAAW,KAAK,SAAS,wBAAwB;AAC/C,WAAO;AAAA,MACL,MAAM;AAAA,MACN,cAAc,KAAK;AAAA,MACnB,SAAS,KAAK;AAAA,IAChB;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,0BAA0B,KAAK,MAAM,CAAC,EAAE;AAAA,EAC1D;AACF;AAEA,eAAe,eAAe,SAAuB;AACnD,QAAM,WAAW;AACjB,MAAI;AAEJ,MAAI,QAAQ,OAAO,QAAQ,MAAM,QAAW;AAC1C,iBAAa,UAAM,6BAAe,OAAO;AACzC,YAAQ,OAAO,QAAQ,IAAI;AAAA,EAC7B;AACA,eAAa,QAAQ,OAAO,QAAQ;AAGpC,MAAI,WAAW,aAAa;AAC1B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,WAAW;AAAA,QACT,KAAK,WAAW;AAAA,QAChB,QAAQ,WAAW;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,MAAI,WAAW,eAAe,QAAW;AACvC,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACtD;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,WAAW;AAAA,MACT,KAAK,QAAQ,WAAW,QAAQ,WAAW,WAAW,UAAU;AAAA,MAChE,QAAQ,WAAW;AAAA,IACrB;AAAA,EACF;AACF;","names":["import_utils","content"]}
{"version":3,"sources":["../../src/inference/tts.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { WebSocket } from 'ws';\nimport { APIError, APIStatusError } from '../_exceptions.js';\nimport { AudioByteStream } from '../audio.js';\nimport { log } from '../log.js';\nimport { createStreamChannel } from '../stream/stream_channel.js';\nimport { basic as tokenizeBasic } from '../tokenize/index.js';\nimport {\n  SynthesizeStream as BaseSynthesizeStream,\n  TTS as BaseTTS,\n  ChunkedStream,\n} from '../tts/index.js';\nimport { type APIConnectOptions, DEFAULT_API_CONNECT_OPTIONS } from '../types.js';\nimport { shortuuid } from '../utils.js';\nimport {\n  type TtsClientEvent,\n  type TtsServerEvent,\n  type TtsSessionCreateEvent,\n  ttsClientEventSchema,\n  ttsServerEventSchema,\n} from './api_protos.js';\nimport { type AnyString, connectWs, createAccessToken } from './utils.js';\n\nexport type CartesiaModels =\n  | 'cartesia'\n  | 'cartesia/sonic'\n  | 'cartesia/sonic-2'\n  | 'cartesia/sonic-turbo';\n\nexport type ElevenlabsModels =\n  | 'elevenlabs'\n  | 'elevenlabs/eleven_flash_v2'\n  | 'elevenlabs/eleven_flash_v2_5'\n  | 'elevenlabs/eleven_turbo_v2'\n  | 'elevenlabs/eleven_turbo_v2_5'\n  | 'elevenlabs/eleven_multilingual_v2';\n\nexport type RimeModels = 'rime' | 'rime/mist' | 'rime/mistv2' | 'rime/arcana';\n\nexport type InworldModels = 'inworld' | 'inworld/inworld-tts-1';\n\nexport interface CartesiaOptions {\n  duration?: number; // max duration of audio in seconds\n  speed?: 'slow' | 'normal' | 'fast'; // default: not specified\n}\n\nexport interface ElevenlabsOptions {\n  inactivity_timeout?: number; // default: 60\n  apply_text_normalization?: 'auto' | 'off' | 'on'; // default: \"auto\"\n}\n\nexport interface RimeOptions {}\n\nexport interface InworldOptions {}\n\ntype _TTSModels = CartesiaModels | ElevenlabsModels | RimeModels | InworldModels;\n\nexport type TTSModels = CartesiaModels | ElevenlabsModels | RimeModels | InworldModels | AnyString;\n\nexport type ModelWithVoice = `${_TTSModels}:${string}` | TTSModels;\n\nexport type TTSOptions<TModel extends TTSModels> = TModel extends CartesiaModels\n  ? CartesiaOptions\n  : TModel extends ElevenlabsModels\n    ? ElevenlabsOptions\n    : TModel extends RimeOptions\n      ? RimeOptions\n      : TModel extends InworldOptions\n        ? InworldOptions\n        : Record<string, unknown>;\n\ntype TTSEncoding = 'pcm_s16le';\n\nconst DEFAULT_ENCODING: TTSEncoding = 'pcm_s16le';\nconst DEFAULT_SAMPLE_RATE = 16000;\nconst DEFAULT_BASE_URL = 'https://agent-gateway.livekit.cloud/v1';\nconst NUM_CHANNELS = 1;\nconst DEFAULT_LANGUAGE = 'en';\n\nexport interface InferenceTTSOptions<TModel extends TTSModels> {\n  model?: TModel;\n  voice?: string;\n  language?: string;\n  encoding: TTSEncoding;\n  sampleRate: number;\n  baseURL: string;\n  apiKey: string;\n  apiSecret: string;\n  modelOptions: TTSOptions<TModel>;\n}\n\n/**\n * Livekit Cloud Inference TTS\n */\nexport class TTS<TModel extends TTSModels> extends BaseTTS {\n  private opts: InferenceTTSOptions<TModel>;\n  private streams: Set<SynthesizeStream<TModel>> = new Set();\n\n  #logger = log();\n\n  constructor(opts: {\n    model: TModel;\n    voice?: string;\n    language?: string;\n    baseURL?: string;\n    encoding?: TTSEncoding;\n    sampleRate?: number;\n    apiKey?: string;\n    apiSecret?: string;\n    modelOptions?: TTSOptions<TModel>;\n  }) {\n    const sampleRate = opts?.sampleRate ?? DEFAULT_SAMPLE_RATE;\n    super(sampleRate, 1, { streaming: true });\n\n    const {\n      model,\n      voice,\n      language = DEFAULT_LANGUAGE,\n      baseURL,\n      encoding = DEFAULT_ENCODING,\n      apiKey,\n      apiSecret,\n      modelOptions = {} as TTSOptions<TModel>,\n    } = opts || {};\n\n    const lkBaseURL = baseURL || process.env.LIVEKIT_INFERENCE_URL || DEFAULT_BASE_URL;\n    const lkApiKey = apiKey || process.env.LIVEKIT_INFERENCE_API_KEY || process.env.LIVEKIT_API_KEY;\n    if (!lkApiKey) {\n      throw new Error('apiKey is required: pass apiKey or set LIVEKIT_API_KEY');\n    }\n\n    const lkApiSecret =\n      apiSecret || process.env.LIVEKIT_INFERENCE_API_SECRET || process.env.LIVEKIT_API_SECRET;\n    if (!lkApiSecret) {\n      throw new Error('apiSecret is required: pass apiSecret or set LIVEKIT_API_SECRET');\n    }\n\n    // read voice id from the model if provided: \"provider/model:voice_id\"\n    let nextModel = model;\n    let nextVoice = voice;\n    if (typeof nextModel === 'string') {\n      const idx = nextModel.lastIndexOf(':');\n      if (idx !== -1) {\n        const voiceFromModel = nextModel.slice(idx + 1);\n        if (nextVoice && nextVoice !== voiceFromModel) {\n          this.#logger.warn(\n            '`voice` is provided via both argument and model, using the one from the argument',\n            { voice: nextVoice, model: nextModel },\n          );\n        } else {\n          nextVoice = voiceFromModel;\n        }\n        nextModel = nextModel.slice(0, idx) as TModel;\n      }\n    }\n\n    this.opts = {\n      model: nextModel,\n      voice: nextVoice,\n      language,\n      encoding,\n      sampleRate,\n      baseURL: lkBaseURL,\n      apiKey: lkApiKey,\n      apiSecret: lkApiSecret,\n      modelOptions,\n    };\n  }\n\n  get label() {\n    return 'inference.TTS';\n  }\n\n  static fromModelString(modelString: string): TTS<AnyString> {\n    if (modelString.includes(':')) {\n      const [model, voice] = modelString.split(':') as [TTSModels, string];\n      return new TTS({ model, voice });\n    }\n    return new TTS({ model: modelString });\n  }\n\n  updateOptions(opts: Partial<Pick<InferenceTTSOptions<TModel>, 'model' | 'voice' | 'language'>>) {\n    this.opts = { ...this.opts, ...opts };\n    for (const stream of this.streams) {\n      stream.updateOptions(opts);\n    }\n  }\n\n  synthesize(_: string): ChunkedStream {\n    throw new Error('ChunkedStream is not implemented');\n  }\n\n  stream(options?: { connOptions?: APIConnectOptions }): SynthesizeStream<TModel> {\n    const { connOptions = DEFAULT_API_CONNECT_OPTIONS } = options || {};\n    const stream = new SynthesizeStream(this, { ...this.opts }, connOptions);\n    this.streams.add(stream);\n    return stream;\n  }\n\n  async connectWs(timeout: number): Promise<WebSocket> {\n    let baseURL = this.opts.baseURL;\n    if (baseURL.startsWith('http://') || baseURL.startsWith('https://')) {\n      baseURL = baseURL.replace('http', 'ws');\n    }\n\n    const token = await createAccessToken(this.opts.apiKey, this.opts.apiSecret);\n    const url = `${baseURL}/tts`;\n    const headers = { Authorization: `Bearer ${token}` } as Record<string, string>;\n\n    const params = {\n      type: 'session.create',\n      sample_rate: String(this.opts.sampleRate),\n      encoding: this.opts.encoding,\n      extra: this.opts.modelOptions,\n    } as TtsSessionCreateEvent;\n\n    if (this.opts.voice) params.voice = this.opts.voice;\n    if (this.opts.model) params.model = this.opts.model;\n    if (this.opts.language) params.language = this.opts.language;\n\n    const socket = await connectWs(url, headers, timeout);\n    socket.send(JSON.stringify(params));\n    return socket;\n  }\n\n  async closeWs(ws: WebSocket) {\n    await ws.close();\n  }\n\n  async close() {\n    for (const stream of this.streams) {\n      await stream.close();\n    }\n    this.streams.clear();\n  }\n}\n\nexport class SynthesizeStream<TModel extends TTSModels> extends BaseSynthesizeStream {\n  private opts: InferenceTTSOptions<TModel>;\n  private tts: TTS<TModel>;\n  private connOptions: APIConnectOptions;\n\n  #logger = log();\n\n  constructor(tts: TTS<TModel>, opts: InferenceTTSOptions<TModel>, connOptions: APIConnectOptions) {\n    super(tts, connOptions);\n    this.opts = opts;\n    this.tts = tts;\n    this.connOptions = connOptions;\n  }\n\n  get label() {\n    return 'inference.SynthesizeStream';\n  }\n\n  updateOptions(opts: Partial<Pick<InferenceTTSOptions<TModel>, 'model' | 'voice' | 'language'>>) {\n    this.opts = { ...this.opts, ...opts };\n  }\n\n  protected async run(): Promise<void> {\n    let ws: WebSocket | null = null;\n    let closing = false;\n    let finalReceived = false;\n    let lastFrame: AudioFrame | undefined;\n\n    const sendTokenizerStream = new tokenizeBasic.SentenceTokenizer().stream();\n    const eventChannel = createStreamChannel<TtsServerEvent>();\n    const requestId = shortuuid('tts_request_');\n\n    const resourceCleanup = () => {\n      if (closing) return;\n      closing = true;\n      sendTokenizerStream.close();\n      eventChannel.close();\n      ws?.removeAllListeners();\n      ws?.close();\n    };\n\n    const sendClientEvent = async (event: TtsClientEvent) => {\n      const validatedEvent = await ttsClientEventSchema.parseAsync(event);\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        this.#logger.warn('Trying to send client TTS event to a closed WebSocket');\n        return;\n      }\n      ws.send(JSON.stringify(validatedEvent));\n    };\n\n    const sendLastFrame = (segmentId: string, final: boolean) => {\n      if (lastFrame) {\n        this.queue.put({ requestId, segmentId, frame: lastFrame, final });\n        lastFrame = undefined;\n      }\n    };\n\n    const createInputTask = async () => {\n      for await (const data of this.input) {\n        if (this.abortController.signal.aborted) break;\n        if (data === SynthesizeStream.FLUSH_SENTINEL) {\n          sendTokenizerStream.flush();\n          continue;\n        }\n        sendTokenizerStream.pushText(data);\n      }\n      sendTokenizerStream.endInput();\n    };\n\n    const createSentenceStreamTask = async () => {\n      for await (const ev of sendTokenizerStream) {\n        if (this.abortController.signal.aborted) break;\n\n        sendClientEvent({\n          type: 'input_transcript',\n          transcript: ev.token + ' ',\n        });\n      }\n\n      sendClientEvent({ type: 'session.flush' });\n    };\n\n    const createWsListenerTask = async (ws: WebSocket) => {\n      return new Promise<void>((resolve, reject) => {\n        this.abortController.signal.addEventListener('abort', () => {\n          resourceCleanup();\n          reject(new Error('WebSocket connection aborted'));\n        });\n\n        ws.on('message', async (data) => {\n          const eventJson = JSON.parse(data.toString()) as Record<string, unknown>;\n          const validatedEvent = ttsServerEventSchema.parse(eventJson);\n          eventChannel.write(validatedEvent);\n        });\n\n        ws.on('error', (e) => {\n          this.#logger.error({ error: e }, 'WebSocket error');\n          resourceCleanup();\n          reject(e);\n        });\n\n        ws.on('close', () => {\n          resourceCleanup();\n\n          if (!closing) return this.#logger.error('WebSocket closed unexpectedly');\n          if (finalReceived) return resolve();\n\n          reject(\n            new APIStatusError({\n              message: 'Gateway connection closed unexpectedly',\n              options: { requestId },\n            }),\n          );\n        });\n      });\n    };\n\n    const createRecvTask = async () => {\n      let currentSessionId: string | null = null;\n\n      const bstream = new AudioByteStream(this.opts.sampleRate, NUM_CHANNELS);\n      const serverEventStream = eventChannel.stream();\n      const reader = serverEventStream.getReader();\n\n      try {\n        while (!this.closed && !this.abortController.signal.aborted) {\n          const result = await reader.read();\n          if (this.abortController.signal.aborted) return;\n          if (result.done) return;\n\n          const serverEvent = result.value;\n          switch (serverEvent.type) {\n            case 'session.created':\n              currentSessionId = serverEvent.session_id;\n              break;\n            case 'output_audio':\n              const base64Data = new Int8Array(Buffer.from(serverEvent.audio, 'base64'));\n              for (const frame of bstream.write(base64Data.buffer)) {\n                sendLastFrame(currentSessionId!, false);\n                lastFrame = frame;\n              }\n              break;\n            case 'done':\n              finalReceived = true;\n              for (const frame of bstream.flush()) {\n                sendLastFrame(currentSessionId!, false);\n                lastFrame = frame;\n              }\n              sendLastFrame(currentSessionId!, true);\n              this.queue.put(SynthesizeStream.END_OF_STREAM);\n              break;\n            case 'session.closed':\n              resourceCleanup();\n              break;\n            case 'error':\n              this.#logger.error(\n                { serverEvent },\n                'Received error message from LiveKit TTS WebSocket',\n              );\n              resourceCleanup();\n              throw new APIError(`LiveKit TTS returned error: ${serverEvent.message}`);\n            default:\n              this.#logger.warn('Unexpected message %s', serverEvent);\n              break;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        try {\n          await serverEventStream.cancel();\n        } catch (e) {\n          this.#logger.debug('Error cancelling serverEventStream (may already be cancelled):', e);\n        }\n      }\n    };\n\n    try {\n      ws = await this.tts.connectWs(this.connOptions.timeoutMs);\n\n      await Promise.all([\n        createInputTask(),\n        createSentenceStreamTask(),\n        createWsListenerTask(ws),\n        createRecvTask(),\n      ]);\n    } catch (e) {\n      this.#logger.error('Error in SynthesizeStream', { error: e });\n    } finally {\n      resourceCleanup();\n    }\n  }\n}\n"],"mappings":"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","names":["import_utils","BaseTTS","BaseSynthesizeStream","tokenizeBasic","ws"]}
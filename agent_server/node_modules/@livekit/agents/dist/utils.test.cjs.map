{"version":3,"sources":["../src/utils.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { AudioFrame } from '@livekit/rtc-node';\nimport { ReadableStream } from 'node:stream/web';\nimport { describe, expect, it } from 'vitest';\nimport { initializeLogger } from '../src/log.js';\nimport {\n  Event,\n  TASK_TIMEOUT_ERROR,\n  Task,\n  TaskResult,\n  delay,\n  isPending,\n  resampleStream,\n} from '../src/utils.js';\n\ndescribe('utils', () => {\n  // initialize logger\n  initializeLogger({ pretty: true, level: 'debug' });\n\n  describe('Task', () => {\n    it('should execute task successfully and return result', async () => {\n      const expectedResult = 'task completed';\n      const task = Task.from(async () => {\n        await delay(10);\n        return expectedResult;\n      });\n\n      expect(task.done).toBe(false);\n      const result = await task.result;\n      expect(result).toBe(expectedResult);\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle task errors properly', async () => {\n      const expectedError = new Error('Task failed');\n      const task = Task.from(async () => {\n        await delay(10);\n        throw expectedError;\n      });\n\n      expect(task.done).toBe(false);\n      await expect(task.result).rejects.toThrow(expectedError);\n      expect(task.done).toBe(true);\n    });\n\n    it('should cancel task when cancel is called', async () => {\n      let taskStarted = false;\n      let taskCompleted = false;\n\n      const task = Task.from(async (controller) => {\n        taskStarted = true;\n        await delay(100, { signal: controller.signal });\n        taskCompleted = true;\n        return 'should not complete';\n      });\n\n      // Wait a bit to ensure task starts\n      await delay(10);\n      expect(taskStarted).toBe(true);\n      expect(task.done).toBe(false);\n\n      // Cancel the task\n      task.cancel();\n\n      // The task should reject with AbortError\n      try {\n        await task.result;\n      } catch (error: unknown) {\n        expect((error as Error).name).toBe('AbortError');\n      }\n\n      expect(taskCompleted).toBe(false);\n      expect(task.done).toBe(true);\n    });\n\n    it('should use provided AbortController', async () => {\n      const controller = new AbortController();\n      const task = Task.from(async (ctrl) => {\n        expect(ctrl).toBe(controller);\n        await delay(100, { signal: ctrl.signal });\n        return 'completed';\n      }, controller);\n\n      await delay(10);\n      controller.abort();\n\n      try {\n        await task.result;\n      } catch (error: unknown) {\n        expect((error as Error).name).toBe('AbortError');\n      }\n\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle immediate resolution', async () => {\n      const task = Task.from(async () => {\n        return 'immediate';\n      });\n\n      const result = await task.result;\n      expect(result).toBe('immediate');\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle immediate rejection', async () => {\n      const expectedError = new Error('Immediate error');\n      const task = Task.from(async () => {\n        throw expectedError;\n      });\n\n      try {\n        await task.result;\n      } catch (error: unknown) {\n        expect(error).toBe(expectedError);\n      }\n\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle multiple calls to cancel', async () => {\n      const task = Task.from(async (controller) => {\n        await delay(100, { signal: controller.signal });\n        return 'should not complete';\n      });\n\n      await delay(10);\n\n      // Multiple cancellations should not cause issues\n      task.cancel();\n      task.cancel();\n      task.cancel();\n\n      try {\n        await task.result;\n      } catch (error: unknown) {\n        expect((error as Error).name).toBe('AbortError');\n      }\n\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle task that checks abort signal manually', async () => {\n      const arr: number[] = [];\n      const task = Task.from(async (controller) => {\n        for (let i = 0; i < 10; i++) {\n          if (controller.signal.aborted) {\n            throw new Error('Task was aborted');\n          }\n          await delay(10);\n          arr.push(i);\n        }\n        return 'completed';\n      });\n\n      await delay(39);\n      task.cancel();\n\n      expect(arr).toEqual([0, 1, 2]);\n      try {\n        await task.result;\n      } catch (error: unknown) {\n        expect((error as Error).message).toBe('Task was aborted');\n      }\n\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle cleanup in finally block', async () => {\n      let cleanupExecuted = false;\n\n      const task = Task.from(async (controller) => {\n        try {\n          await delay(100, { signal: controller.signal });\n          return 'completed';\n        } finally {\n          cleanupExecuted = true;\n        }\n      });\n\n      await delay(10);\n      task.cancel();\n\n      try {\n        await task.result;\n      } catch {\n        // Ignore the abort error\n      }\n\n      // Cleanup should still execute even when cancelled\n      expect(cleanupExecuted).toBe(true);\n    });\n\n    it('should handle accessing result multiple times', async () => {\n      const task = Task.from(async () => {\n        await delay(10);\n        return 'result';\n      });\n\n      const result1 = await task.result;\n      const result2 = await task.result;\n      const result3 = await task.result;\n\n      expect(result1).toBe('result');\n      expect(result2).toBe('result');\n      expect(result3).toBe('result');\n      expect(task.done).toBe(true);\n    });\n\n    it('should handle accessing result promise before completion', async () => {\n      const task = Task.from(async () => {\n        await delay(50);\n        return 'delayed result';\n      });\n\n      // Get references to result promise before completion\n      const resultPromise1 = task.result;\n      const resultPromise2 = task.result;\n\n      expect(task.done).toBe(false);\n\n      // Both promises should resolve to the same value\n      const [result1, result2] = await Promise.all([resultPromise1, resultPromise2]);\n\n      expect(result1).toBe('delayed result');\n      expect(result2).toBe('delayed result');\n      expect(task.done).toBe(true);\n    });\n\n    it('should cancel child tasks when parent task is canceled', async () => {\n      let parentStarted = false;\n      let child1Started = false;\n      let child2Started = false;\n      let parentCompleted = false;\n      let child1Completed = false;\n      let child2Completed = false;\n\n      let child1Task: Task<string> | undefined = undefined;\n      let child2Task: Task<string> | undefined = undefined;\n\n      const parentTask = Task.from(async (controller) => {\n        parentStarted = true;\n\n        // Create two child tasks using the parent's controller\n        child1Task = Task.from(async (childController) => {\n          child1Started = true;\n          await delay(100, { signal: childController.signal });\n          child1Completed = true;\n          return 'child1';\n        }, controller);\n\n        child2Task = Task.from(async (childController) => {\n          child2Started = true;\n          await delay(100, { signal: childController.signal });\n          child2Completed = true;\n          return 'child2';\n        }, controller);\n\n        // Wait for both child tasks\n        const results = await Promise.all([child1Task.result, child2Task.result]);\n        parentCompleted = true;\n        return results;\n      });\n\n      // Let tasks start\n      await delay(20);\n\n      // Verify tasks have started\n      expect(parentStarted).toBe(true);\n      expect(child1Started).toBe(true);\n      expect(child2Started).toBe(true);\n\n      // Cancel parent task\n      parentTask.cancel();\n\n      // Use Promise.allSettled to handle all promise settlements\n      const [parentResult, child1Result, child2Result] = await Promise.allSettled([\n        parentTask.result,\n        child1Task!.result,\n        child2Task!.result,\n      ]);\n\n      // Verify all tasks were rejected with AbortError\n      expect(parentResult.status).toBe('rejected');\n      expect((parentResult as PromiseRejectedResult).reason.name).toBe('AbortError');\n\n      expect(child1Result.status).toBe('rejected');\n      expect((child1Result as PromiseRejectedResult).reason.name).toBe('AbortError');\n\n      expect(child2Result.status).toBe('rejected');\n      expect((child2Result as PromiseRejectedResult).reason.name).toBe('AbortError');\n\n      // Verify none of the tasks completed\n      expect(parentCompleted).toBe(false);\n      expect(child1Completed).toBe(false);\n      expect(child2Completed).toBe(false);\n      expect(parentTask.done).toBe(true);\n      expect(child1Task!.done).toBe(true);\n      expect(child2Task!.done).toBe(true);\n    });\n\n    it('should handle nested tasks that complete successfully', async () => {\n      const results: string[] = [];\n\n      const parentTask = Task.from(async (controller) => {\n        results.push('parent-start');\n\n        // Create first child task\n        const child1Task = Task.from(async () => {\n          results.push('child1-start');\n          await delay(25);\n          results.push('child1-end');\n          return 'child1-result';\n        }, controller);\n\n        // Create second child task that depends on first\n        const child2Task = Task.from(async (childController) => {\n          results.push('child2-start');\n\n          // Create a grandchild task\n          const grandchildTask = Task.from(async () => {\n            results.push('grandchild-start');\n            await delay(10);\n            results.push('grandchild-end');\n            return 'grandchild-result';\n          }, childController);\n\n          const grandchildResult = await grandchildTask.result;\n          await delay(10);\n          results.push('child2-end');\n          return `child2-result-with-${grandchildResult}`;\n        }, controller);\n\n        // Wait for all tasks\n        const [child1Result, child2Result] = await Promise.all([\n          child1Task.result,\n          child2Task.result,\n        ]);\n\n        results.push('parent-end');\n        return {\n          parent: 'parent-result',\n          child1: child1Result,\n          child2: child2Result,\n        };\n      });\n\n      // Wait for everything to complete\n      const finalResult = await parentTask.result;\n\n      // Verify results\n      expect(finalResult).toEqual({\n        parent: 'parent-result',\n        child1: 'child1-result',\n        child2: 'child2-result-with-grandchild-result',\n      });\n\n      // Verify execution order\n      // Check important ordering constraints without being strict about parallel task ordering\n      expect(results).toEqual([\n        'parent-start',\n        'child1-start',\n        'child2-start',\n        'grandchild-start',\n        'grandchild-end',\n        'child2-end',\n        'child1-end',\n        'parent-end',\n      ]);\n\n      // All tasks should be done\n      expect(parentTask.done).toBe(true);\n    });\n\n    it('should propagate errors from nested tasks', async () => {\n      let parentError: Error | null = null;\n      let child1Completed = false;\n      let child2Started = false;\n\n      const parentTask = Task.from(async (controller) => {\n        const child1Task = Task.from(async () => {\n          await delay(20);\n          throw new Error('child1 error');\n        }, controller);\n\n        const child2Task = Task.from(async () => {\n          child2Started = true;\n          await delay(30);\n          child1Completed = true;\n          return 'child2-result';\n        }, controller);\n\n        // This will throw when child1 fails\n        const results = await Promise.all([child1Task.result, child2Task.result]);\n        return results;\n      });\n\n      // Wait for the parent task to fail\n      try {\n        await parentTask.result;\n        expect.fail('Parent task should have thrown');\n      } catch (error: unknown) {\n        parentError = error as Error;\n      }\n\n      // Verify the error propagated correctly\n      expect(parentError?.message).toBe('child1 error');\n      expect(child1Completed).toBe(false);\n      expect(child2Started).toBe(true);\n      expect(parentTask.done).toBe(true);\n    });\n\n    it('should cancel and wait for task completion', async () => {\n      let taskCompleted = false;\n\n      const task = Task.from(async (controller) => {\n        await delay(5000, { signal: controller.signal });\n        taskCompleted = true;\n        return 'should not complete';\n      });\n\n      // Cancel and wait should complete quickly when task is aborted\n      const start = Date.now();\n      const result = await task.cancelAndWait(1000);\n      const duration = Date.now() - start;\n\n      expect(result).toBe(TaskResult.Aborted);\n      expect(duration).toBeLessThan(100); // Should not wait for full timeout\n      expect(taskCompleted).toBe(false);\n      expect(task.done).toBe(true);\n    });\n\n    it('should timeout if task does not respond to cancellation', async () => {\n      const task = Task.from(async () => {\n        await delay(1000);\n      });\n\n      // This should timeout because the task ignores cancellation\n      try {\n        await task.cancelAndWait(200);\n        expect.fail('Task should have timed out');\n      } catch (error: unknown) {\n        expect(error).toBe(TASK_TIMEOUT_ERROR);\n      }\n    });\n\n    it('should handle task that completes before timeout', async () => {\n      const task = Task.from(async () => {\n        await delay(50);\n      });\n\n      // Start the task\n      await delay(10);\n\n      // Cancel and wait - but task will complete normally before being canceled\n      const result = await task.cancelAndWait(1000);\n\n      // Task should have completed normally\n      expect(result).toBe(TaskResult.Completed);\n      expect(task.done).toBe(true);\n    });\n\n    it('should propagate non-abort errors from cancelAndWait', async () => {\n      const task = Task.from(async () => {\n        await delay(10);\n        throw new TypeError('Custom error');\n      });\n\n      try {\n        await task.cancelAndWait(1000);\n        expect.fail('Task should have thrown');\n      } catch (error: unknown) {\n        expect((error as Error).message).toBe('Custom error');\n        expect((error as Error).name).toBe('TypeError');\n      }\n    });\n  });\n\n  describe('Event', () => {\n    it('wait resolves immediately when the event is already set', async () => {\n      const event = new Event();\n      event.set();\n\n      const result = await event.wait();\n      expect(result).toBe(true);\n    });\n\n    it('wait resolves after set is called', async () => {\n      // check promise is pending\n      const event = new Event();\n      const waiterPromise = event.wait();\n\n      await delay(10);\n      expect(await isPending(waiterPromise)).toBe(true);\n\n      // check promise is resolved after set is called\n      event.set();\n      const result = await waiterPromise;\n      expect(result).toBe(true);\n    });\n\n    it('all waiters resolve once set is called', async () => {\n      const event = new Event();\n      const waiters = [event.wait(), event.wait(), event.wait()];\n\n      await delay(10);\n      const pendings = await Promise.all(waiters.map((w) => isPending(w)));\n      expect(pendings).toEqual([true, true, true]);\n\n      event.set();\n      const results = await Promise.all(waiters);\n      expect(results).toEqual([true, true, true]);\n    });\n\n    it('wait after 2 seconds is still pending before set', async () => {\n      const event = new Event();\n      const waiter = event.wait();\n\n      await delay(2000);\n      expect(await isPending(waiter)).toBe(true);\n\n      event.set();\n      const result = await waiter;\n      expect(result).toBe(true);\n    });\n\n    it('wait after set and clear should be pending', async () => {\n      const event = new Event();\n      const waiterBeforeSet = event.wait();\n      event.set();\n      event.clear();\n\n      const waiterAfterSet = event.wait();\n\n      const result = await Promise.race([\n        waiterBeforeSet.then(() => 'before'),\n        waiterAfterSet.then(() => 'after'),\n      ]);\n\n      expect(result).toBe('before');\n      expect(await isPending(waiterBeforeSet)).toBe(false);\n      expect(await isPending(waiterAfterSet)).toBe(true);\n\n      event.set();\n      expect(await waiterAfterSet).toBe(true);\n    });\n  });\n\n  describe('resampleStream', () => {\n    const createAudioFrame = (sampleRate: number, samples: number, channels = 1): AudioFrame => {\n      const data = new Int16Array(samples * channels);\n      for (let i = 0; i < data.length; i++) {\n        data[i] = Math.sin((i / samples) * Math.PI * 2) * 16000;\n      }\n      return new AudioFrame(data, sampleRate, channels, samples);\n    };\n\n    const streamToArray = async (stream: ReadableStream<AudioFrame>): Promise<AudioFrame[]> => {\n      const reader = stream.getReader();\n      const chunks: AudioFrame[] = [];\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          chunks.push(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n      return chunks;\n    };\n\n    it('should resample audio frames to target sample rate', async () => {\n      const inputRate = 48000;\n      const outputRate = 16000;\n      const inputFrame = createAudioFrame(inputRate, 960); // 20ms at 48kHz\n\n      const inputStream = new ReadableStream<AudioFrame>({\n        start(controller) {\n          controller.enqueue(inputFrame);\n          controller.close();\n        },\n      });\n\n      const outputStream = resampleStream({ stream: inputStream, outputRate });\n      const outputFrames = await streamToArray(outputStream);\n\n      expect(outputFrames.length).toBeGreaterThan(0);\n\n      for (const frame of outputFrames) {\n        expect(frame.sampleRate).toBe(outputRate);\n        expect(frame.channels).toBe(inputFrame.channels);\n      }\n    });\n\n    it('should handle same input and output rate', async () => {\n      const sampleRate = 44100;\n      const inputFrame = createAudioFrame(sampleRate, 1024);\n\n      const inputStream = new ReadableStream<AudioFrame>({\n        start(controller) {\n          controller.enqueue(inputFrame);\n          controller.close();\n        },\n      });\n\n      const outputStream = resampleStream({ stream: inputStream, outputRate: sampleRate });\n      const outputFrames = await streamToArray(outputStream);\n\n      expect(outputFrames.length).toBeGreaterThan(0);\n\n      for (const frame of outputFrames) {\n        expect(frame.sampleRate).toBe(sampleRate);\n        expect(frame.channels).toBe(inputFrame.channels);\n      }\n    });\n\n    it('should handle multiple input frames', async () => {\n      const inputRate = 32000;\n      const outputRate = 48000;\n      const frame1 = createAudioFrame(inputRate, 640);\n      const frame2 = createAudioFrame(inputRate, 640);\n\n      const inputStream = new ReadableStream<AudioFrame>({\n        start(controller) {\n          controller.enqueue(frame1);\n          controller.enqueue(frame2);\n          controller.close();\n        },\n      });\n\n      const outputStream = resampleStream({ stream: inputStream, outputRate });\n      const outputFrames = await streamToArray(outputStream);\n\n      expect(outputFrames.length).toBeGreaterThan(0);\n\n      for (const frame of outputFrames) {\n        expect(frame.sampleRate).toBe(outputRate);\n        expect(frame.channels).toBe(frame1.channels);\n      }\n    });\n\n    it('should handle empty stream', async () => {\n      const inputStream = new ReadableStream<AudioFrame>({\n        start(controller) {\n          controller.close();\n        },\n      });\n\n      const outputStream = resampleStream({ stream: inputStream, outputRate: 44100 });\n      const outputFrames = await streamToArray(outputStream);\n\n      expect(outputFrames).toEqual([]);\n    });\n  });\n});\n"],"mappings":"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","names":[]}
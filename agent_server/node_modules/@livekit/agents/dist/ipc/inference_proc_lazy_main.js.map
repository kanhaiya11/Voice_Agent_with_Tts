{"version":3,"sources":["../../src/ipc/inference_proc_lazy_main.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { once } from 'node:events';\nimport type { InferenceRunner } from '../inference_runner.js';\nimport { initializeLogger, log } from '../log.js';\nimport { Future } from '../utils.js';\nimport type { IPCMessage } from './message.js';\n\nconst ORPHANED_TIMEOUT = 15 * 1000;\n\n(async () => {\n  if (process.send) {\n    const join = new Future();\n\n    // don't do anything on C-c\n    // this is handled in cli, triggering a termination of all child processes at once.\n    process.on('SIGINT', () => {\n      logger.debug('SIGINT received in inference proc');\n    });\n\n    // don't do anything on SIGTERM\n    // Render uses SIGTERM in autoscale, this ensures the processes are properly drained if needed\n    process.on('SIGTERM', () => {\n      logger.debug('SIGTERM received in inference proc');\n    });\n\n    await once(process, 'message').then(([msg]: IPCMessage[]) => {\n      msg = msg!;\n      if (msg.case !== 'initializeRequest') {\n        throw new Error('first message must be InitializeRequest');\n      }\n      initializeLogger(msg.value.loggerOptions);\n    });\n    const logger = log().child({ pid: process.pid });\n\n    const runners: { [id: string]: InferenceRunner } = await Promise.all(\n      Object.entries(JSON.parse(process.argv[2]!)).map(async ([k, v]) => {\n        return [k, await import(v as string).then((m) => new m.default())];\n      }),\n    ).then(Object.fromEntries);\n\n    await Promise.all(\n      Object.entries(runners).map(async ([runner, v]) => {\n        logger.child({ runner }).debug('initializing inference runner');\n        await v.initialize();\n      }),\n    );\n    logger.debug('all inference runners initialized');\n    process.send({ case: 'initializeResponse' });\n\n    const orphanedTimeout = setTimeout(() => {\n      logger.warn('inference process orphaned, shutting down.');\n      process.exit();\n    }, ORPHANED_TIMEOUT);\n\n    const handleInferenceRequest = async ({\n      method,\n      requestId,\n      data,\n    }: {\n      method: string;\n      requestId: string;\n      data: unknown;\n    }) => {\n      if (!runners[method]) {\n        logger.child({ method }).warn('unknown inference method');\n      }\n\n      try {\n        const resp = await runners[method]!.run(data);\n        process.send!({ case: 'inferenceResponse', value: { requestId, data: resp } });\n      } catch (error) {\n        process.send!({ case: 'inferenceResponse', value: { requestId, error } });\n      }\n    };\n\n    const messageHandler = (msg: IPCMessage) => {\n      switch (msg.case) {\n        case 'pingRequest':\n          orphanedTimeout.refresh();\n          process.send!({\n            case: 'pongResponse',\n            value: { lastTimestamp: msg.value.timestamp, timestamp: Date.now() },\n          });\n          break;\n        case 'shutdownRequest':\n          logger.debug('inference process received shutdown request');\n          clearTimeout(orphanedTimeout);\n          // Remove our message handler to stop processing new messages\n          process.off('message', messageHandler);\n          Promise.all(Object.values(runners).map((r) => r.close()))\n            .then(() => {\n              logger.debug('Inference runners closed');\n              process.send!({ case: 'done' });\n              join.resolve();\n            })\n            .catch((err) => {\n              logger.error('Error closing inference runners:', err);\n            });\n          break;\n        case 'inferenceRequest':\n          handleInferenceRequest(msg.value);\n      }\n    };\n\n    process.on('message', messageHandler);\n\n    await join.await;\n\n    logger.debug('Inference process shutdown');\n\n    return process.exitCode;\n  }\n})();\n"],"mappings":"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","names":[]}
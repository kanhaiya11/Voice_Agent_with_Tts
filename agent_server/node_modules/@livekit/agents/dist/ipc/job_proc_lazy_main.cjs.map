{"version":3,"sources":["../../src/ipc/job_proc_lazy_main.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { Room, RoomEvent } from '@livekit/rtc-node';\nimport { EventEmitter, once } from 'node:events';\nimport { pathToFileURL } from 'node:url';\nimport type { Logger } from 'pino';\nimport { type Agent, isAgent } from '../generator.js';\nimport { JobContext, JobProcess, type RunningJobInfo, runWithJobContextAsync } from '../job.js';\nimport { initializeLogger, log } from '../log.js';\nimport { Future, shortuuid } from '../utils.js';\nimport { defaultInitializeProcessFunc } from '../worker.js';\nimport type { InferenceExecutor } from './inference_executor.js';\nimport type { IPCMessage } from './message.js';\n\nconst ORPHANED_TIMEOUT = 15 * 1000;\n\ntype JobTask = {\n  ctx: JobContext;\n  task: Promise<void>;\n};\n\nclass PendingInference {\n  promise = new Promise<{ requestId: string; data: unknown; error?: Error }>((resolve) => {\n    this.resolve = resolve; // this is how JavaScript lets you resolve promises externally\n  });\n  resolve(arg: { requestId: string; data: unknown; error?: Error }) {\n    arg; // useless call to counteract TypeScript E6133\n  }\n}\n\nclass InfClient implements InferenceExecutor {\n  #requests: { [id: string]: PendingInference } = {};\n\n  constructor() {\n    process.on('message', (msg: IPCMessage) => {\n      switch (msg.case) {\n        case 'inferenceResponse':\n          const fut = this.#requests[msg.value.requestId];\n          delete this.#requests[msg.value.requestId];\n          if (!fut) {\n            log().child({ resp: msg.value }).warn('received unexpected inference response');\n            return;\n          }\n          fut.resolve(msg.value);\n          break;\n      }\n    });\n  }\n\n  async doInference(method: string, data: unknown): Promise<unknown> {\n    const requestId = shortuuid('inference_job_');\n    process.send!({ case: 'inferenceRequest', value: { requestId, method, data } });\n    this.#requests[requestId] = new PendingInference();\n    const resp = await this.#requests[requestId]!.promise;\n    if (resp.error) {\n      throw new Error(`inference of ${method} failed: ${resp.error.message}`);\n    }\n    return resp.data;\n  }\n}\n\nconst startJob = (\n  proc: JobProcess,\n  func: (ctx: JobContext) => Promise<void>,\n  info: RunningJobInfo,\n  closeEvent: EventEmitter,\n  logger: Logger,\n  joinFuture: Future,\n): JobTask => {\n  let connect = false;\n  let shutdown = false;\n\n  const room = new Room();\n  room.on(RoomEvent.Disconnected, () => {\n    if (!shutdown) {\n      closeEvent.emit('close', false);\n    }\n  });\n\n  const onConnect = () => {\n    connect = true;\n  };\n  const onShutdown = (reason: string) => {\n    shutdown = true;\n    closeEvent.emit('close', true, reason);\n  };\n\n  const ctx = new JobContext(proc, info, room, onConnect, onShutdown, new InfClient());\n\n  const task = new Promise<void>(async () => {\n    const unconnectedTimeout = setTimeout(() => {\n      if (!(connect || shutdown)) {\n        logger.warn(\n          'room not connect after job_entry was called after 10 seconds, ',\n          'did you forget to call ctx.connect()?',\n        );\n      }\n    }, 10000);\n\n    // Run the job function within the AsyncLocalStorage context\n    await runWithJobContextAsync(ctx, () => func(ctx)).finally(() => {\n      clearTimeout(unconnectedTimeout);\n    });\n\n    await once(closeEvent, 'close').then((close) => {\n      logger.debug('shutting down');\n      shutdown = true;\n      process.send!({ case: 'exiting', value: { reason: close[1] } });\n    });\n\n    await room.disconnect();\n    logger.debug('disconnected from room');\n\n    const shutdownTasks = [];\n    for (const callback of ctx.shutdownCallbacks) {\n      shutdownTasks.push(callback());\n    }\n    await Promise.all(shutdownTasks).catch((error) =>\n      logger.error('error while shutting down the job', error),\n    );\n\n    process.send!({ case: 'done' });\n    joinFuture.resolve();\n  });\n\n  return { ctx, task };\n};\n\n(async () => {\n  if (process.send) {\n    const join = new Future();\n\n    // process.argv:\n    //   [0] `node'\n    //   [1] import.meta.filename\n    //   [2] import.meta.filename of function containing entry file\n    const moduleFile = process.argv[2];\n    const agent: Agent = await import(pathToFileURL(moduleFile!).pathname).then((module) => {\n      const agent = module.default;\n      if (agent === undefined || !isAgent(agent)) {\n        throw new Error(`Unable to load agent: Missing or invalid default export in ${moduleFile}`);\n      }\n      return agent;\n    });\n    if (!agent.prewarm) {\n      agent.prewarm = defaultInitializeProcessFunc;\n    }\n\n    // don't do anything on C-c\n    // this is handled in cli, triggering a termination of all child processes at once.\n    process.on('SIGINT', () => {\n      logger.debug('SIGINT received in job proc');\n    });\n\n    // don't do anything on SIGTERM\n    // Render uses SIGTERM in autoscale, this ensures the processes are properly drained if needed\n    process.on('SIGTERM', () => {\n      logger.debug('SIGTERM received in job proc');\n    });\n\n    await once(process, 'message').then(([msg]: IPCMessage[]) => {\n      msg = msg!;\n      if (msg.case !== 'initializeRequest') {\n        throw new Error('first message must be InitializeRequest');\n      }\n      initializeLogger(msg.value.loggerOptions);\n    });\n    const proc = new JobProcess();\n    let logger = log().child({ pid: proc.pid });\n\n    process.on('unhandledRejection', (reason) => {\n      logger.error(reason);\n    });\n\n    logger.debug('initializing job runner');\n    agent.prewarm(proc);\n    logger.debug('job runner initialized');\n    process.send({ case: 'initializeResponse' });\n\n    let job: JobTask | undefined = undefined;\n    const closeEvent = new EventEmitter();\n\n    const orphanedTimeout = setTimeout(() => {\n      logger.warn('job process orphaned, shutting down.');\n      join.resolve();\n    }, ORPHANED_TIMEOUT);\n\n    const messageHandler = (msg: IPCMessage) => {\n      switch (msg.case) {\n        case 'pingRequest': {\n          orphanedTimeout.refresh();\n          process.send!({\n            case: 'pongResponse',\n            value: { lastTimestamp: msg.value.timestamp, timestamp: Date.now() },\n          });\n          break;\n        }\n        case 'startJobRequest': {\n          if (job) {\n            throw new Error('job task already running');\n          }\n\n          logger = logger.child({ jobID: msg.value.runningJob.job.id });\n\n          job = startJob(proc, agent.entry, msg.value.runningJob, closeEvent, logger, join);\n          logger.debug('job started');\n          break;\n        }\n        case 'shutdownRequest': {\n          if (!job) {\n            join.resolve();\n          }\n          closeEvent.emit('close', 'shutdownRequest');\n          clearTimeout(orphanedTimeout);\n          process.off('message', messageHandler);\n        }\n      }\n    };\n\n    process.on('message', messageHandler);\n\n    await join.await;\n\n    logger.debug('Job process shutdown');\n    process.exit(0);\n  }\n})();\n"],"mappings":"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","names":["module","agent"]}
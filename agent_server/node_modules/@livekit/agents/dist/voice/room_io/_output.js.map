{"version":3,"sources":["../../../src/voice/room_io/_output.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { RemoteParticipant } from '@livekit/rtc-node';\nimport {\n  type AudioFrame,\n  AudioSource,\n  LocalAudioTrack,\n  type LocalTrackPublication,\n  type Participant,\n  type RemoteTrackPublication,\n  type Room,\n  RoomEvent,\n  type TextStreamWriter,\n  TrackPublishOptions,\n  TrackSource,\n} from '@livekit/rtc-node';\nimport {\n  ATTRIBUTE_TRANSCRIPTION_FINAL,\n  ATTRIBUTE_TRANSCRIPTION_SEGMENT_ID,\n  ATTRIBUTE_TRANSCRIPTION_TRACK_ID,\n  TOPIC_TRANSCRIPTION,\n} from '../../constants.js';\nimport { log } from '../../log.js';\nimport { Future, Task, shortuuid } from '../../utils.js';\nimport { AudioOutput, TextOutput } from '../io.js';\nimport { findMicrophoneTrackId } from '../transcription/index.js';\n\nabstract class BaseParticipantTranscriptionOutput extends TextOutput {\n  protected room: Room;\n  protected isDeltaStream: boolean;\n  protected participantIdentity: string | null = null;\n  protected trackId?: string;\n  protected capturing: boolean = false;\n  protected latestText: string = '';\n  protected currentId: string = this.generateCurrentId();\n  protected logger = log();\n\n  constructor(room: Room, isDeltaStream: boolean, participant: Participant | string | null) {\n    super();\n    this.room = room;\n    this.isDeltaStream = isDeltaStream;\n\n    this.room.on(RoomEvent.TrackPublished, this.onTrackPublished);\n    this.room.on(RoomEvent.LocalTrackPublished, this.onLocalTrackPublished);\n\n    this.setParticipant(participant);\n  }\n\n  setParticipant(participant: Participant | string | null) {\n    if (typeof participant === 'string' || participant === null) {\n      this.participantIdentity = participant;\n    } else {\n      this.participantIdentity = participant.identity;\n    }\n\n    if (!this.participantIdentity) {\n      return;\n    }\n\n    try {\n      this.trackId = findMicrophoneTrackId(this.room, this.participantIdentity);\n    } catch (error) {\n      // track id is optional for TextStream when audio is not published\n    }\n\n    this.flush();\n    this.resetState();\n  }\n\n  protected onTrackPublished = (track: RemoteTrackPublication, participant: RemoteParticipant) => {\n    if (\n      !this.participantIdentity ||\n      participant.identity !== this.participantIdentity ||\n      track.source !== TrackSource.SOURCE_MICROPHONE\n    ) {\n      return;\n    }\n\n    this.trackId = track.sid;\n  };\n\n  protected onLocalTrackPublished = (track: LocalTrackPublication) => {\n    if (\n      !this.participantIdentity ||\n      this.participantIdentity !== this.room.localParticipant?.identity ||\n      track.source !== TrackSource.SOURCE_MICROPHONE\n    ) {\n      return;\n    }\n\n    this.trackId = track.sid;\n  };\n\n  protected generateCurrentId(): string {\n    return shortuuid('SG_');\n  }\n\n  protected resetState() {\n    this.currentId = this.generateCurrentId();\n    this.capturing = false;\n    this.latestText = '';\n  }\n\n  async captureText(text: string) {\n    if (!this.participantIdentity) {\n      return;\n    }\n\n    this.latestText = text;\n    await this.handleCaptureText(text);\n  }\n\n  flush() {\n    if (!this.participantIdentity || !this.capturing) {\n      return;\n    }\n\n    this.capturing = false;\n    this.handleFlush();\n  }\n\n  protected abstract handleCaptureText(text: string): Promise<void>;\n  protected abstract handleFlush(): void;\n}\n\nexport class ParticipantTranscriptionOutput extends BaseParticipantTranscriptionOutput {\n  private writer: TextStreamWriter | null = null;\n  private flushTask: Task<void> | null = null;\n\n  protected async handleCaptureText(text: string): Promise<void> {\n    if (this.flushTask && !this.flushTask.done) {\n      await this.flushTask.result;\n    }\n\n    if (!this.capturing) {\n      this.resetState();\n      this.capturing = true;\n    }\n\n    try {\n      if (this.room.isConnected) {\n        if (this.isDeltaStream) {\n          // reuse the existing writer\n          if (this.writer === null) {\n            this.writer = await this.createTextWriter();\n          }\n          await this.writer.write(text);\n        } else {\n          const tmpWriter = await this.createTextWriter();\n          await tmpWriter.write(text);\n          await tmpWriter.close();\n        }\n      }\n    } catch (error) {\n      this.logger.error(error, 'failed to publish transcription');\n    }\n  }\n\n  protected handleFlush() {\n    const currWriter = this.writer;\n    this.writer = null;\n    this.flushTask = Task.from((controller) => this.flushTaskImpl(currWriter, controller.signal));\n  }\n\n  private async createTextWriter(attributes?: Record<string, string>): Promise<TextStreamWriter> {\n    if (!this.participantIdentity) {\n      throw new Error('participantIdentity not found');\n    }\n\n    if (!this.room.localParticipant) {\n      throw new Error('localParticipant not found');\n    }\n\n    if (!attributes) {\n      attributes = {\n        [ATTRIBUTE_TRANSCRIPTION_FINAL]: 'false',\n      };\n      if (this.trackId) {\n        attributes[ATTRIBUTE_TRANSCRIPTION_TRACK_ID] = this.trackId;\n      }\n    }\n    attributes[ATTRIBUTE_TRANSCRIPTION_SEGMENT_ID] = this.currentId;\n\n    return await this.room.localParticipant.streamText({\n      topic: TOPIC_TRANSCRIPTION,\n      senderIdentity: this.participantIdentity,\n      attributes,\n    });\n  }\n\n  private async flushTaskImpl(writer: TextStreamWriter | null, signal: AbortSignal): Promise<void> {\n    const attributes: Record<string, string> = {\n      [ATTRIBUTE_TRANSCRIPTION_FINAL]: 'true',\n    };\n    if (this.trackId) {\n      attributes[ATTRIBUTE_TRANSCRIPTION_TRACK_ID] = this.trackId;\n    }\n\n    const abortPromise = new Promise<void>((resolve) => {\n      signal.addEventListener('abort', () => resolve());\n    });\n\n    try {\n      if (this.room.isConnected) {\n        if (this.isDeltaStream) {\n          if (writer) {\n            await Promise.race([writer.close(), abortPromise]);\n          }\n        } else {\n          const tmpWriter = await Promise.race([this.createTextWriter(attributes), abortPromise]);\n          if (signal.aborted || !tmpWriter) {\n            return;\n          }\n          await Promise.race([tmpWriter.write(this.latestText), abortPromise]);\n          if (signal.aborted) {\n            return;\n          }\n          await Promise.race([tmpWriter.close(), abortPromise]);\n        }\n      }\n    } catch (error) {\n      this.logger.error(error, 'failed to publish transcription');\n    }\n  }\n}\n\nexport class ParticipantLegacyTranscriptionOutput extends BaseParticipantTranscriptionOutput {\n  private pushedText: string = '';\n  private flushTask: Promise<void> | null = null;\n\n  protected async handleCaptureText(text: string): Promise<void> {\n    if (!this.trackId) {\n      return;\n    }\n\n    if (this.flushTask) {\n      await this.flushTask;\n    }\n\n    if (!this.capturing) {\n      this.resetState();\n      this.capturing = true;\n    }\n\n    if (this.isDeltaStream) {\n      this.pushedText += text;\n    } else {\n      this.pushedText = text;\n    }\n\n    await this.publishTranscription(this.currentId, this.pushedText, false);\n  }\n\n  protected handleFlush() {\n    if (!this.trackId) {\n      return;\n    }\n\n    this.flushTask = this.publishTranscription(this.currentId, this.pushedText, true);\n    this.resetState();\n  }\n\n  async publishTranscription(id: string, text: string, final: boolean, signal?: AbortSignal) {\n    if (!this.participantIdentity || !this.trackId) {\n      return;\n    }\n\n    try {\n      if (this.room.isConnected) {\n        if (signal?.aborted) {\n          return;\n        }\n\n        await this.room.localParticipant?.publishTranscription({\n          participantIdentity: this.participantIdentity,\n          trackSid: this.trackId,\n          segments: [{ id, text, final, startTime: BigInt(0), endTime: BigInt(0), language: '' }],\n        });\n      }\n    } catch (error) {\n      this.logger.error(error, 'failed to publish transcription');\n    }\n  }\n\n  protected resetState() {\n    super.resetState();\n    this.pushedText = '';\n  }\n}\n\nexport class ParalellTextOutput extends TextOutput {\n  /** @internal */\n  _sinks: TextOutput[];\n\n  constructor(sinks: TextOutput[], nextInChain?: TextOutput) {\n    super(nextInChain);\n    this._sinks = sinks;\n  }\n\n  async captureText(text: string) {\n    await Promise.all(this._sinks.map((sink) => sink.captureText(text)));\n  }\n\n  flush() {\n    for (const sink of this._sinks) {\n      sink.flush();\n    }\n  }\n}\n\nexport interface AudioOutputOptions {\n  sampleRate: number;\n  numChannels: number;\n  trackPublishOptions: TrackPublishOptions;\n  queueSizeMs?: number;\n}\nexport class ParticipantAudioOutput extends AudioOutput {\n  private room: Room;\n  private options: AudioOutputOptions;\n  private audioSource: AudioSource;\n  private publication?: LocalTrackPublication;\n  private flushTask?: Task<void>;\n  private pushedDurationMs: number = 0;\n  private startedFuture: Future<void> = new Future();\n  private interruptedFuture: Future<void> = new Future();\n\n  constructor(room: Room, options: AudioOutputOptions) {\n    super(options.sampleRate);\n    this.room = room;\n    this.options = options;\n    this.audioSource = new AudioSource(options.sampleRate, options.numChannels);\n  }\n\n  get subscribed(): boolean {\n    return this.startedFuture.done;\n  }\n\n  async start(signal: AbortSignal): Promise<void> {\n    await this.publishTrack(signal);\n  }\n\n  async captureFrame(frame: AudioFrame): Promise<void> {\n    await this.startedFuture.await;\n\n    super.captureFrame(frame);\n\n    // TODO(AJS-102): use frame.durationMs once available in rtc-node\n    this.pushedDurationMs += frame.samplesPerChannel / frame.sampleRate;\n    await this.audioSource.captureFrame(frame);\n  }\n\n  private async waitForPlayoutTask(abortController: AbortController): Promise<void> {\n    const abortFuture = new Future<boolean>();\n\n    const resolveAbort = () => {\n      if (!abortFuture.done) abortFuture.resolve(true);\n    };\n\n    abortController.signal.addEventListener('abort', resolveAbort);\n\n    this.audioSource.waitForPlayout().finally(() => {\n      abortController.signal.removeEventListener('abort', resolveAbort);\n      if (!abortFuture.done) abortFuture.resolve(false);\n    });\n\n    const interrupted = await Promise.race([\n      abortFuture.await,\n      this.interruptedFuture.await.then(() => true),\n    ]);\n\n    let pushedDuration = this.pushedDurationMs;\n\n    if (interrupted) {\n      // Calculate actual played duration accounting for queued audio\n      pushedDuration = Math.max(this.pushedDurationMs - this.audioSource.queuedDuration, 0);\n      this.audioSource.clearQueue();\n    }\n\n    this.pushedDurationMs = 0;\n    this.interruptedFuture = new Future();\n    this.onPlaybackFinished({\n      playbackPosition: pushedDuration,\n      interrupted,\n    });\n  }\n\n  /**\n   * Flush any buffered audio, marking the current playback/segment as complete\n   */\n  flush(): void {\n    super.flush();\n\n    if (!this.pushedDurationMs) {\n      return;\n    }\n\n    if (this.flushTask && !this.flushTask.done) {\n      this.logger.error('flush called while playback is in progress');\n      this.flushTask.cancel();\n    }\n\n    this.flushTask = Task.from((controller) => this.waitForPlayoutTask(controller));\n  }\n\n  clearBuffer(): void {\n    if (!this.pushedDurationMs) {\n      return;\n    }\n\n    this.interruptedFuture.resolve();\n  }\n\n  private async publishTrack(signal: AbortSignal) {\n    const track = LocalAudioTrack.createAudioTrack('roomio_audio', this.audioSource);\n    this.publication = await this.room.localParticipant?.publishTrack(\n      track,\n      new TrackPublishOptions({ source: TrackSource.SOURCE_MICROPHONE }),\n    );\n\n    if (signal.aborted) {\n      return;\n    }\n\n    await this.publication?.waitForSubscription();\n\n    if (!this.startedFuture.done) {\n      this.startedFuture.resolve();\n    }\n  }\n\n  async close() {\n    // TODO(AJS-106): add republish track\n    await this.audioSource.close();\n  }\n}\n"],"mappings":"AAIA;AAAA,EAEE;AAAA,EACA;AAAA,EAKA;AAAA,EAEA;AAAA,EACA;AAAA,OACK;AACP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,WAAW;AACpB,SAAS,QAAQ,MAAM,iBAAiB;AACxC,SAAS,aAAa,kBAAkB;AACxC,SAAS,6BAA6B;AAEtC,MAAe,2CAA2C,WAAW;AAAA,EACzD;AAAA,EACA;AAAA,EACA,sBAAqC;AAAA,EACrC;AAAA,EACA,YAAqB;AAAA,EACrB,aAAqB;AAAA,EACrB,YAAoB,KAAK,kBAAkB;AAAA,EAC3C,SAAS,IAAI;AAAA,EAEvB,YAAY,MAAY,eAAwB,aAA0C;AACxF,UAAM;AACN,SAAK,OAAO;AACZ,SAAK,gBAAgB;AAErB,SAAK,KAAK,GAAG,UAAU,gBAAgB,KAAK,gBAAgB;AAC5D,SAAK,KAAK,GAAG,UAAU,qBAAqB,KAAK,qBAAqB;AAEtE,SAAK,eAAe,WAAW;AAAA,EACjC;AAAA,EAEA,eAAe,aAA0C;AACvD,QAAI,OAAO,gBAAgB,YAAY,gBAAgB,MAAM;AAC3D,WAAK,sBAAsB;AAAA,IAC7B,OAAO;AACL,WAAK,sBAAsB,YAAY;AAAA,IACzC;AAEA,QAAI,CAAC,KAAK,qBAAqB;AAC7B;AAAA,IACF;AAEA,QAAI;AACF,WAAK,UAAU,sBAAsB,KAAK,MAAM,KAAK,mBAAmB;AAAA,IAC1E,SAAS,OAAO;AAAA,IAEhB;AAEA,SAAK,MAAM;AACX,SAAK,WAAW;AAAA,EAClB;AAAA,EAEU,mBAAmB,CAAC,OAA+B,gBAAmC;AAC9F,QACE,CAAC,KAAK,uBACN,YAAY,aAAa,KAAK,uBAC9B,MAAM,WAAW,YAAY,mBAC7B;AACA;AAAA,IACF;AAEA,SAAK,UAAU,MAAM;AAAA,EACvB;AAAA,EAEU,wBAAwB,CAAC,UAAiC;AAlFtE;AAmFI,QACE,CAAC,KAAK,uBACN,KAAK,0BAAwB,UAAK,KAAK,qBAAV,mBAA4B,aACzD,MAAM,WAAW,YAAY,mBAC7B;AACA;AAAA,IACF;AAEA,SAAK,UAAU,MAAM;AAAA,EACvB;AAAA,EAEU,oBAA4B;AACpC,WAAO,UAAU,KAAK;AAAA,EACxB;AAAA,EAEU,aAAa;AACrB,SAAK,YAAY,KAAK,kBAAkB;AACxC,SAAK,YAAY;AACjB,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAM,YAAY,MAAc;AAC9B,QAAI,CAAC,KAAK,qBAAqB;AAC7B;AAAA,IACF;AAEA,SAAK,aAAa;AAClB,UAAM,KAAK,kBAAkB,IAAI;AAAA,EACnC;AAAA,EAEA,QAAQ;AACN,QAAI,CAAC,KAAK,uBAAuB,CAAC,KAAK,WAAW;AAChD;AAAA,IACF;AAEA,SAAK,YAAY;AACjB,SAAK,YAAY;AAAA,EACnB;AAIF;AAEO,MAAM,uCAAuC,mCAAmC;AAAA,EAC7E,SAAkC;AAAA,EAClC,YAA+B;AAAA,EAEvC,MAAgB,kBAAkB,MAA6B;AAC7D,QAAI,KAAK,aAAa,CAAC,KAAK,UAAU,MAAM;AAC1C,YAAM,KAAK,UAAU;AAAA,IACvB;AAEA,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAEA,QAAI;AACF,UAAI,KAAK,KAAK,aAAa;AACzB,YAAI,KAAK,eAAe;AAEtB,cAAI,KAAK,WAAW,MAAM;AACxB,iBAAK,SAAS,MAAM,KAAK,iBAAiB;AAAA,UAC5C;AACA,gBAAM,KAAK,OAAO,MAAM,IAAI;AAAA,QAC9B,OAAO;AACL,gBAAM,YAAY,MAAM,KAAK,iBAAiB;AAC9C,gBAAM,UAAU,MAAM,IAAI;AAC1B,gBAAM,UAAU,MAAM;AAAA,QACxB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,OAAO,iCAAiC;AAAA,IAC5D;AAAA,EACF;AAAA,EAEU,cAAc;AACtB,UAAM,aAAa,KAAK;AACxB,SAAK,SAAS;AACd,SAAK,YAAY,KAAK,KAAK,CAAC,eAAe,KAAK,cAAc,YAAY,WAAW,MAAM,CAAC;AAAA,EAC9F;AAAA,EAEA,MAAc,iBAAiB,YAAgE;AAC7F,QAAI,CAAC,KAAK,qBAAqB;AAC7B,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,QAAI,CAAC,KAAK,KAAK,kBAAkB;AAC/B,YAAM,IAAI,MAAM,4BAA4B;AAAA,IAC9C;AAEA,QAAI,CAAC,YAAY;AACf,mBAAa;AAAA,QACX,CAAC,6BAA6B,GAAG;AAAA,MACnC;AACA,UAAI,KAAK,SAAS;AAChB,mBAAW,gCAAgC,IAAI,KAAK;AAAA,MACtD;AAAA,IACF;AACA,eAAW,kCAAkC,IAAI,KAAK;AAEtD,WAAO,MAAM,KAAK,KAAK,iBAAiB,WAAW;AAAA,MACjD,OAAO;AAAA,MACP,gBAAgB,KAAK;AAAA,MACrB;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,cAAc,QAAiC,QAAoC;AAC/F,UAAM,aAAqC;AAAA,MACzC,CAAC,6BAA6B,GAAG;AAAA,IACnC;AACA,QAAI,KAAK,SAAS;AAChB,iBAAW,gCAAgC,IAAI,KAAK;AAAA,IACtD;AAEA,UAAM,eAAe,IAAI,QAAc,CAAC,YAAY;AAClD,aAAO,iBAAiB,SAAS,MAAM,QAAQ,CAAC;AAAA,IAClD,CAAC;AAED,QAAI;AACF,UAAI,KAAK,KAAK,aAAa;AACzB,YAAI,KAAK,eAAe;AACtB,cAAI,QAAQ;AACV,kBAAM,QAAQ,KAAK,CAAC,OAAO,MAAM,GAAG,YAAY,CAAC;AAAA,UACnD;AAAA,QACF,OAAO;AACL,gBAAM,YAAY,MAAM,QAAQ,KAAK,CAAC,KAAK,iBAAiB,UAAU,GAAG,YAAY,CAAC;AACtF,cAAI,OAAO,WAAW,CAAC,WAAW;AAChC;AAAA,UACF;AACA,gBAAM,QAAQ,KAAK,CAAC,UAAU,MAAM,KAAK,UAAU,GAAG,YAAY,CAAC;AACnE,cAAI,OAAO,SAAS;AAClB;AAAA,UACF;AACA,gBAAM,QAAQ,KAAK,CAAC,UAAU,MAAM,GAAG,YAAY,CAAC;AAAA,QACtD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,OAAO,iCAAiC;AAAA,IAC5D;AAAA,EACF;AACF;AAEO,MAAM,6CAA6C,mCAAmC;AAAA,EACnF,aAAqB;AAAA,EACrB,YAAkC;AAAA,EAE1C,MAAgB,kBAAkB,MAA6B;AAC7D,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA,IACF;AAEA,QAAI,KAAK,WAAW;AAClB,YAAM,KAAK;AAAA,IACb;AAEA,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,WAAW;AAChB,WAAK,YAAY;AAAA,IACnB;AAEA,QAAI,KAAK,eAAe;AACtB,WAAK,cAAc;AAAA,IACrB,OAAO;AACL,WAAK,aAAa;AAAA,IACpB;AAEA,UAAM,KAAK,qBAAqB,KAAK,WAAW,KAAK,YAAY,KAAK;AAAA,EACxE;AAAA,EAEU,cAAc;AACtB,QAAI,CAAC,KAAK,SAAS;AACjB;AAAA,IACF;AAEA,SAAK,YAAY,KAAK,qBAAqB,KAAK,WAAW,KAAK,YAAY,IAAI;AAChF,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,MAAM,qBAAqB,IAAY,MAAc,OAAgB,QAAsB;AAvQ7F;AAwQI,QAAI,CAAC,KAAK,uBAAuB,CAAC,KAAK,SAAS;AAC9C;AAAA,IACF;AAEA,QAAI;AACF,UAAI,KAAK,KAAK,aAAa;AACzB,YAAI,iCAAQ,SAAS;AACnB;AAAA,QACF;AAEA,gBAAM,UAAK,KAAK,qBAAV,mBAA4B,qBAAqB;AAAA,UACrD,qBAAqB,KAAK;AAAA,UAC1B,UAAU,KAAK;AAAA,UACf,UAAU,CAAC,EAAE,IAAI,MAAM,OAAO,WAAW,OAAO,CAAC,GAAG,SAAS,OAAO,CAAC,GAAG,UAAU,GAAG,CAAC;AAAA,QACxF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,OAAO,iCAAiC;AAAA,IAC5D;AAAA,EACF;AAAA,EAEU,aAAa;AACrB,UAAM,WAAW;AACjB,SAAK,aAAa;AAAA,EACpB;AACF;AAEO,MAAM,2BAA2B,WAAW;AAAA;AAAA,EAEjD;AAAA,EAEA,YAAY,OAAqB,aAA0B;AACzD,UAAM,WAAW;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,YAAY,MAAc;AAC9B,UAAM,QAAQ,IAAI,KAAK,OAAO,IAAI,CAAC,SAAS,KAAK,YAAY,IAAI,CAAC,CAAC;AAAA,EACrE;AAAA,EAEA,QAAQ;AACN,eAAW,QAAQ,KAAK,QAAQ;AAC9B,WAAK,MAAM;AAAA,IACb;AAAA,EACF;AACF;AAQO,MAAM,+BAA+B,YAAY;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,mBAA2B;AAAA,EAC3B,gBAA8B,IAAI,OAAO;AAAA,EACzC,oBAAkC,IAAI,OAAO;AAAA,EAErD,YAAY,MAAY,SAA6B;AACnD,UAAM,QAAQ,UAAU;AACxB,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,SAAK,cAAc,IAAI,YAAY,QAAQ,YAAY,QAAQ,WAAW;AAAA,EAC5E;AAAA,EAEA,IAAI,aAAsB;AACxB,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA,EAEA,MAAM,MAAM,QAAoC;AAC9C,UAAM,KAAK,aAAa,MAAM;AAAA,EAChC;AAAA,EAEA,MAAM,aAAa,OAAkC;AACnD,UAAM,KAAK,cAAc;AAEzB,UAAM,aAAa,KAAK;AAGxB,SAAK,oBAAoB,MAAM,oBAAoB,MAAM;AACzD,UAAM,KAAK,YAAY,aAAa,KAAK;AAAA,EAC3C;AAAA,EAEA,MAAc,mBAAmB,iBAAiD;AAChF,UAAM,cAAc,IAAI,OAAgB;AAExC,UAAM,eAAe,MAAM;AACzB,UAAI,CAAC,YAAY,KAAM,aAAY,QAAQ,IAAI;AAAA,IACjD;AAEA,oBAAgB,OAAO,iBAAiB,SAAS,YAAY;AAE7D,SAAK,YAAY,eAAe,EAAE,QAAQ,MAAM;AAC9C,sBAAgB,OAAO,oBAAoB,SAAS,YAAY;AAChE,UAAI,CAAC,YAAY,KAAM,aAAY,QAAQ,KAAK;AAAA,IAClD,CAAC;AAED,UAAM,cAAc,MAAM,QAAQ,KAAK;AAAA,MACrC,YAAY;AAAA,MACZ,KAAK,kBAAkB,MAAM,KAAK,MAAM,IAAI;AAAA,IAC9C,CAAC;AAED,QAAI,iBAAiB,KAAK;AAE1B,QAAI,aAAa;AAEf,uBAAiB,KAAK,IAAI,KAAK,mBAAmB,KAAK,YAAY,gBAAgB,CAAC;AACpF,WAAK,YAAY,WAAW;AAAA,IAC9B;AAEA,SAAK,mBAAmB;AACxB,SAAK,oBAAoB,IAAI,OAAO;AACpC,SAAK,mBAAmB;AAAA,MACtB,kBAAkB;AAAA,MAClB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,UAAM,MAAM;AAEZ,QAAI,CAAC,KAAK,kBAAkB;AAC1B;AAAA,IACF;AAEA,QAAI,KAAK,aAAa,CAAC,KAAK,UAAU,MAAM;AAC1C,WAAK,OAAO,MAAM,4CAA4C;AAC9D,WAAK,UAAU,OAAO;AAAA,IACxB;AAEA,SAAK,YAAY,KAAK,KAAK,CAAC,eAAe,KAAK,mBAAmB,UAAU,CAAC;AAAA,EAChF;AAAA,EAEA,cAAoB;AAClB,QAAI,CAAC,KAAK,kBAAkB;AAC1B;AAAA,IACF;AAEA,SAAK,kBAAkB,QAAQ;AAAA,EACjC;AAAA,EAEA,MAAc,aAAa,QAAqB;AA7ZlD;AA8ZI,UAAM,QAAQ,gBAAgB,iBAAiB,gBAAgB,KAAK,WAAW;AAC/E,SAAK,cAAc,QAAM,UAAK,KAAK,qBAAV,mBAA4B;AAAA,MACnD;AAAA,MACA,IAAI,oBAAoB,EAAE,QAAQ,YAAY,kBAAkB,CAAC;AAAA;AAGnE,QAAI,OAAO,SAAS;AAClB;AAAA,IACF;AAEA,YAAM,UAAK,gBAAL,mBAAkB;AAExB,QAAI,CAAC,KAAK,cAAc,MAAM;AAC5B,WAAK,cAAc,QAAQ;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,MAAM,QAAQ;AAEZ,UAAM,KAAK,YAAY,MAAM;AAAA,EAC/B;AACF;","names":[]}
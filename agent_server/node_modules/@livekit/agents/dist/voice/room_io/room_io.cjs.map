{"version":3,"sources":["../../../src/voice/room_io/room_io.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  ConnectionState,\n  DisconnectReason,\n  type NoiseCancellationOptions,\n  type Participant,\n  ParticipantKind,\n  type RemoteParticipant,\n  type Room,\n  RoomEvent,\n  type TextStreamInfo,\n  type TextStreamReader,\n  TrackPublishOptions,\n  TrackSource,\n} from '@livekit/rtc-node';\nimport type { WritableStreamDefaultWriter } from 'node:stream/web';\nimport { ATTRIBUTE_PUBLISH_ON_BEHALF, TOPIC_CHAT } from '../../constants.js';\nimport { log } from '../../log.js';\nimport { IdentityTransform } from '../../stream/identity_transform.js';\nimport { Future, Task } from '../../utils.js';\nimport { type AgentSession } from '../agent_session.js';\nimport {\n  AgentSessionEventTypes,\n  type AgentStateChangedEvent,\n  CloseReason,\n  type UserInputTranscribedEvent,\n} from '../events.js';\nimport type { AudioOutput, TextOutput } from '../io.js';\nimport { TranscriptionSynchronizer } from '../transcription/synchronizer.js';\nimport { ParticipantAudioInputStream } from './_input.js';\nimport {\n  ParalellTextOutput,\n  ParticipantAudioOutput,\n  ParticipantLegacyTranscriptionOutput,\n  ParticipantTranscriptionOutput,\n} from './_output.js';\n\nexport interface TextInputEvent {\n  text: string;\n  info: TextStreamInfo;\n  participant: RemoteParticipant;\n}\n\nexport type TextInputCallback = (sess: AgentSession, ev: TextInputEvent) => void | Promise<void>;\n\nconst DEFAULT_TEXT_INPUT_CALLBACK: TextInputCallback = (sess: AgentSession, ev: TextInputEvent) => {\n  sess.interrupt();\n  sess.generateReply({ userInput: ev.text });\n};\n\nconst DEFAULT_PARTICIPANT_KINDS: ParticipantKind[] = [\n  ParticipantKind.SIP,\n  ParticipantKind.STANDARD,\n];\n\nconst CLOSE_ON_DISCONNECT_REASONS: DisconnectReason[] = [\n  DisconnectReason.CLIENT_INITIATED,\n  DisconnectReason.ROOM_DELETED,\n  DisconnectReason.USER_REJECTED,\n];\n\nexport interface RoomInputOptions {\n  audioSampleRate: number;\n  audioNumChannels: number;\n  /** If not given, default to True. */\n  textEnabled: boolean;\n  /** If not given, default to True. */\n  audioEnabled: boolean;\n  /** If not given, default to False. */\n  videoEnabled: boolean;\n  /** The participant to link to. If not provided, link to the first participant.\n    Can be overridden by the `participant` argument of RoomIO constructor or `set_participant`.\n  */\n  participantIdentity?: string;\n  noiseCancellation?: NoiseCancellationOptions;\n  textInputCallback?: TextInputCallback;\n  /** Participant kinds accepted for auto subscription. If not provided,\n    accept `DEFAULT_PARTICIPANT_KINDS`\n  */\n  participantKinds?: ParticipantKind[];\n  /** Close the AgentSession if the linked participant disconnects with reasons in\n    CLIENT_INITIATED, ROOM_DELETED, or USER_REJECTED.\n  */\n  closeOnDisconnect: boolean;\n}\n\nexport interface RoomOutputOptions {\n  /** If not given, default to True. */\n  transcriptionEnabled: boolean;\n  /** If not given, default to True. */\n  audioEnabled: boolean;\n  audioSampleRate: number;\n  audioNumChannels: number;\n  /** False to disable transcription synchronization with audio output.\n    Otherwise, transcription is emitted as quickly as available.\n  */\n  syncTranscription: boolean;\n  /** The name of the audio track to publish. If not provided, default to \"roomio_audio\".\n   */\n  audioPublishOptions: TrackPublishOptions;\n}\n\nconst DEFAULT_ROOM_INPUT_OPTIONS: RoomInputOptions = {\n  audioSampleRate: 24000,\n  audioNumChannels: 1,\n  textEnabled: true,\n  audioEnabled: true,\n  videoEnabled: false,\n  textInputCallback: DEFAULT_TEXT_INPUT_CALLBACK,\n  closeOnDisconnect: true,\n};\n\nconst DEFAULT_ROOM_OUTPUT_OPTIONS: RoomOutputOptions = {\n  audioSampleRate: 24000,\n  audioNumChannels: 1,\n  transcriptionEnabled: true,\n  audioEnabled: true,\n  syncTranscription: true,\n  audioPublishOptions: new TrackPublishOptions({ source: TrackSource.SOURCE_MICROPHONE }),\n};\n\nexport class RoomIO {\n  private agentSession: AgentSession;\n  private room: Room;\n  private inputOptions: RoomInputOptions;\n  private outputOptions: RoomOutputOptions;\n\n  private audioInput?: ParticipantAudioInputStream;\n  private participantAudioOutput?: ParticipantAudioOutput;\n  private userTranscriptOutput?: ParalellTextOutput;\n  private agentTranscriptOutput?: ParalellTextOutput;\n  private transcriptionSynchronizer?: TranscriptionSynchronizer;\n  private participantIdentity: string | null = null;\n\n  private participantAvailableFuture: Future<RemoteParticipant> = new Future();\n  private roomConnectedFuture: Future<void> = new Future();\n\n  // Use stream API for transcript queue\n  private userTranscriptStream = new IdentityTransform<UserInputTranscribedEvent>();\n  private userTranscriptWriter: WritableStreamDefaultWriter<UserInputTranscribedEvent>;\n  private forwardUserTranscriptTask?: Task<void>;\n  private initTask?: Task<void>;\n\n  private textStreamHandlerRegistered = false;\n\n  private logger = log();\n\n  constructor({\n    agentSession,\n    room,\n    participant = null,\n    inputOptions,\n    outputOptions,\n  }: {\n    agentSession: AgentSession;\n    room: Room;\n    participant?: RemoteParticipant | string | null;\n    inputOptions?: Partial<RoomInputOptions>;\n    outputOptions?: Partial<RoomOutputOptions>;\n  }) {\n    this.agentSession = agentSession;\n    this.room = room;\n    this.inputOptions = { ...DEFAULT_ROOM_INPUT_OPTIONS, ...inputOptions };\n    this.outputOptions = { ...DEFAULT_ROOM_OUTPUT_OPTIONS, ...outputOptions };\n\n    this.userTranscriptWriter = this.userTranscriptStream.writable.getWriter();\n\n    this.participantIdentity = participant\n      ? typeof participant === 'string'\n        ? participant\n        : participant.identity\n      : this.inputOptions.participantIdentity ?? null;\n  }\n  private async init(signal: AbortSignal): Promise<void> {\n    await this.roomConnectedFuture.await;\n\n    for (const participant of this.room.remoteParticipants.values()) {\n      this.onParticipantConnected(participant);\n    }\n    if (signal.aborted) {\n      return;\n    }\n\n    const participant = await this.participantAvailableFuture.await;\n    this.setParticipant(participant.identity);\n\n    // init agent outputs\n    this.updateTranscriptionOutput({\n      output: this.agentTranscriptOutput,\n      participant: this.room.localParticipant?.identity ?? null,\n    });\n\n    await this.participantAudioOutput?.start(signal);\n  }\n\n  private onConnectionStateChanged = (state: ConnectionState) => {\n    this.logger.debug({ state }, 'connection state changed');\n    if (\n      state === ConnectionState.CONN_CONNECTED &&\n      this.room.isConnected &&\n      !this.roomConnectedFuture.done\n    ) {\n      this.roomConnectedFuture.resolve();\n    }\n  };\n\n  private onParticipantConnected = (participant: RemoteParticipant) => {\n    if (this.participantAvailableFuture.done) {\n      return;\n    }\n\n    if (this.participantIdentity) {\n      if (participant.identity !== this.participantIdentity) {\n        return;\n      }\n    } else if (\n      // otherwise, skip participants that are marked as publishing for this agent\n      participant.attributes?.[ATTRIBUTE_PUBLISH_ON_BEHALF] === this.room.localParticipant?.identity\n    ) {\n      return;\n    }\n\n    const acceptedKinds = this.inputOptions.participantKinds ?? DEFAULT_PARTICIPANT_KINDS;\n    if (participant.info.kind !== undefined && !acceptedKinds.includes(participant.info.kind)) {\n      return;\n    }\n\n    this.participantAvailableFuture.resolve(participant);\n  };\n\n  private onParticipantDisconnected = (participant: RemoteParticipant) => {\n    if (participant.identity !== this.participantIdentity) {\n      return;\n    }\n    this.participantAvailableFuture = new Future<RemoteParticipant>();\n    if (\n      this.inputOptions.closeOnDisconnect &&\n      participant.disconnectReason &&\n      CLOSE_ON_DISCONNECT_REASONS.includes(participant.disconnectReason)\n    ) {\n      this.logger.info(\n        {\n          participant: participant.identity,\n          reason: DisconnectReason[participant.disconnectReason],\n        },\n        'closing agent session due to participant disconnect ' +\n          '(disable via `RoomInputOptions.closeOnDisconnect=False`)',\n      );\n      this.agentSession._closeSoon({\n        reason: CloseReason.PARTICIPANT_DISCONNECTED,\n      });\n    }\n  };\n\n  private onUserInputTranscribed = (ev: UserInputTranscribedEvent) => {\n    this.userTranscriptWriter.write(ev).catch((error) => {\n      this.logger.error({ error }, 'Failed to write transcript event to stream');\n    });\n  };\n\n  private onAgentStateChanged = async (ev: AgentStateChangedEvent) => {\n    if (this.room.isConnected && this.room.localParticipant) {\n      await this.room.localParticipant.setAttributes({\n        [`lk.agent.state`]: ev.newState,\n      });\n    }\n  };\n\n  private onUserTextInput = (reader: TextStreamReader, participantInfo: { identity: string }) => {\n    if (participantInfo.identity !== this.participantIdentity) {\n      return;\n    }\n\n    const participant = this.room.remoteParticipants.get(participantInfo.identity);\n    if (!participant) {\n      this.logger.warn('participant not found, ignoring text input');\n      return;\n    }\n\n    const readText = async () => {\n      const text = await reader.readAll();\n\n      const textInputResult = this.inputOptions.textInputCallback!(this.agentSession, {\n        text,\n        info: reader.info,\n        participant,\n      });\n\n      // check if callback is a Promise\n      if (textInputResult instanceof Promise) {\n        await textInputResult;\n      }\n    };\n\n    readText().catch((error) => {\n      this.logger.error({ error }, 'Error reading text input');\n    });\n  };\n\n  private async forwardUserTranscript(signal: AbortSignal): Promise<void> {\n    const reader = this.userTranscriptStream.readable.getReader();\n    try {\n      while (!signal.aborted) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const event = value;\n        // IMPORTANT: need to await here to avoid race condition\n        await this.userTranscriptOutput?.captureText(event.transcript);\n        if (event.isFinal) {\n          this.userTranscriptOutput?.flush();\n        }\n      }\n    } catch (error) {\n      this.logger.error({ error }, 'Error processing transcript stream');\n    }\n  }\n\n  private createTranscriptionOutput(options: {\n    isDeltaStream: boolean;\n    participant: Participant | string | null;\n  }) {\n    return new ParalellTextOutput([\n      new ParticipantLegacyTranscriptionOutput(\n        this.room,\n        options.isDeltaStream,\n        options.participant,\n      ),\n      new ParticipantTranscriptionOutput(this.room, options.isDeltaStream, options.participant),\n    ]);\n  }\n\n  private updateTranscriptionOutput({\n    output,\n    participant,\n  }: {\n    output?: ParalellTextOutput;\n    participant: string | null;\n  }) {\n    if (!output) {\n      return;\n    }\n\n    for (const sink of output._sinks) {\n      if (\n        sink instanceof ParticipantLegacyTranscriptionOutput ||\n        sink instanceof ParticipantTranscriptionOutput\n      ) {\n        sink.setParticipant(participant);\n      }\n    }\n  }\n\n  get audioOutput(): AudioOutput | undefined {\n    if (!this.transcriptionSynchronizer) {\n      return this.participantAudioOutput;\n    }\n\n    return this.transcriptionSynchronizer.audioOutput;\n  }\n\n  get transcriptionOutput(): TextOutput | undefined {\n    if (!this.transcriptionSynchronizer) {\n      return this.agentTranscriptOutput;\n    }\n\n    return this.transcriptionSynchronizer.textOutput;\n  }\n\n  /** Switch to a different participant */\n  setParticipant(participantIdentity: string | null) {\n    this.logger.debug({ participantIdentity }, 'setting participant');\n    if (participantIdentity === null) {\n      this.unsetParticipant();\n      return;\n    }\n\n    if (this.participantIdentity !== participantIdentity) {\n      this.participantAvailableFuture = new Future<RemoteParticipant>();\n\n      // check if new participant is already connected\n      for (const participant of this.room.remoteParticipants.values()) {\n        if (participant.identity === participantIdentity) {\n          this.participantAvailableFuture.resolve(participant);\n          break;\n        }\n      }\n    }\n\n    // update participant identity and handlers\n    this.participantIdentity = participantIdentity;\n    this.audioInput?.setParticipant(participantIdentity);\n    this.updateTranscriptionOutput({\n      output: this.userTranscriptOutput,\n      participant: participantIdentity,\n    });\n  }\n\n  unsetParticipant() {\n    this.participantIdentity = null;\n    this.participantAvailableFuture = new Future<RemoteParticipant>();\n    this.audioInput?.setParticipant(null);\n    this.updateTranscriptionOutput({\n      output: this.userTranscriptOutput,\n      participant: null,\n    });\n  }\n\n  start() {\n    if (this.inputOptions.textEnabled) {\n      try {\n        this.room.registerTextStreamHandler(TOPIC_CHAT, this.onUserTextInput);\n        this.textStreamHandlerRegistered = true;\n      } catch (error) {\n        if (this.inputOptions.textEnabled) {\n          this.logger.warn(`text stream handler for topic \"${TOPIC_CHAT}\" already set, ignoring`);\n        }\n      }\n    }\n\n    // -- create inputs --\n    if (this.inputOptions.audioEnabled) {\n      this.audioInput = new ParticipantAudioInputStream({\n        room: this.room,\n        sampleRate: this.inputOptions.audioSampleRate,\n        numChannels: this.inputOptions.audioNumChannels,\n        noiseCancellation: this.inputOptions.noiseCancellation,\n      });\n    }\n\n    // -- create outputs --\n    if (this.outputOptions.audioEnabled) {\n      this.participantAudioOutput = new ParticipantAudioOutput(this.room, {\n        sampleRate: this.outputOptions.audioSampleRate,\n        numChannels: this.outputOptions.audioNumChannels,\n        trackPublishOptions: this.outputOptions.audioPublishOptions,\n      });\n    }\n    if (this.outputOptions.transcriptionEnabled) {\n      this.userTranscriptOutput = this.createTranscriptionOutput({\n        isDeltaStream: false,\n        participant: this.participantIdentity,\n      });\n      // Start the transcript forwarding\n      this.forwardUserTranscriptTask = Task.from((controller) =>\n        this.forwardUserTranscript(controller.signal),\n      );\n      this.agentTranscriptOutput = this.createTranscriptionOutput({\n        isDeltaStream: true,\n        participant: null,\n      });\n\n      // use the RoomIO's audio output if available, otherwise use the agent's audio output\n      // TODO(AJS-176): check for agent output\n      const audioOutput = this.participantAudioOutput;\n      if (this.outputOptions.syncTranscription && audioOutput) {\n        this.transcriptionSynchronizer = new TranscriptionSynchronizer(\n          audioOutput,\n          this.agentTranscriptOutput,\n        );\n      }\n    }\n\n    // -- set the room event handlers --\n    this.room.on(RoomEvent.ParticipantConnected, this.onParticipantConnected);\n    this.room.on(RoomEvent.ConnectionStateChanged, this.onConnectionStateChanged);\n    this.room.on(RoomEvent.ParticipantDisconnected, this.onParticipantDisconnected);\n    if (this.room.isConnected) {\n      this.onConnectionStateChanged(ConnectionState.CONN_CONNECTED);\n    }\n\n    this.initTask = Task.from((controller) => this.init(controller.signal));\n\n    // attach the agent to the session\n    if (this.audioInput) {\n      this.agentSession.input.audio = this.audioInput;\n    }\n    if (this.audioOutput) {\n      this.agentSession.output.audio = this.audioOutput;\n    }\n    if (this.transcriptionOutput) {\n      this.agentSession.output.transcription = this.transcriptionOutput;\n    }\n\n    this.agentSession.on(AgentSessionEventTypes.AgentStateChanged, this.onAgentStateChanged);\n    this.agentSession.on(AgentSessionEventTypes.UserInputTranscribed, this.onUserInputTranscribed);\n  }\n\n  async close() {\n    this.room.off(RoomEvent.ParticipantConnected, this.onParticipantConnected);\n    this.room.off(RoomEvent.ConnectionStateChanged, this.onConnectionStateChanged);\n    this.room.off(RoomEvent.ParticipantDisconnected, this.onParticipantDisconnected);\n    this.agentSession.off(AgentSessionEventTypes.UserInputTranscribed, this.onUserInputTranscribed);\n    this.agentSession.off(AgentSessionEventTypes.AgentStateChanged, this.onAgentStateChanged);\n\n    if (this.textStreamHandlerRegistered) {\n      this.room.unregisterTextStreamHandler(TOPIC_CHAT);\n      this.textStreamHandlerRegistered = false;\n    }\n\n    await this.initTask?.cancelAndWait();\n\n    // Close stream FIRST so reader.read() in forwardUserTranscript can exit.\n    // This is a workaround for a race condition in the stream API.\n    this.userTranscriptWriter.close();\n    await this.forwardUserTranscriptTask?.cancelAndWait();\n\n    await this.audioInput?.close();\n    await this.participantAudioOutput?.close();\n    await this.transcriptionSynchronizer?.close();\n  }\n}\n"],"mappings":"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","names":["participant"]}
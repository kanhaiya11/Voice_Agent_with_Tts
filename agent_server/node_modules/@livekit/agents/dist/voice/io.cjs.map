{"version":3,"sources":["../../src/voice/io.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { EventEmitter } from 'node:events';\nimport type { ReadableStream } from 'node:stream/web';\nimport type { ChatContext } from '../llm/chat_context.js';\nimport type { ChatChunk } from '../llm/llm.js';\nimport type { ToolContext } from '../llm/tool_context.js';\nimport { log } from '../log.js';\nimport { DeferredReadableStream } from '../stream/deferred_stream.js';\nimport type { SpeechEvent } from '../stt/stt.js';\nimport { Future } from '../utils.js';\nimport type { ModelSettings } from './agent.js';\n\nexport type STTNode = (\n  audio: ReadableStream<AudioFrame>,\n  modelSettings: ModelSettings,\n) => Promise<ReadableStream<SpeechEvent | string> | null>;\n\nexport type LLMNode = (\n  chatCtx: ChatContext,\n  toolCtx: ToolContext,\n  modelSettings: ModelSettings,\n) => Promise<ReadableStream<ChatChunk | string> | null>;\n\nexport type TTSNode = (\n  text: ReadableStream<string>,\n  modelSettings: ModelSettings,\n) => Promise<ReadableStream<AudioFrame> | null>;\nexport abstract class AudioInput {\n  protected deferredStream: DeferredReadableStream<AudioFrame> =\n    new DeferredReadableStream<AudioFrame>();\n\n  get stream(): ReadableStream<AudioFrame> {\n    return this.deferredStream.stream;\n  }\n\n  onAttached(): void {}\n\n  onDetached(): void {}\n}\n\nexport abstract class AudioOutput extends EventEmitter {\n  static readonly EVENT_PLAYBACK_FINISHED = 'playbackFinished';\n\n  private playbackFinishedFuture: Future<void> = new Future();\n  private _capturing: boolean = false;\n  private playbackFinishedCount: number = 0;\n  private playbackSegmentsCount: number = 0;\n  private lastPlaybackEvent: PlaybackFinishedEvent = {\n    playbackPosition: 0,\n    interrupted: false,\n  };\n  protected logger = log();\n\n  constructor(\n    public sampleRate?: number,\n    protected readonly nextInChain?: AudioOutput,\n  ) {\n    super();\n    if (this.nextInChain) {\n      this.nextInChain.on(AudioOutput.EVENT_PLAYBACK_FINISHED, (ev: PlaybackFinishedEvent) =>\n        this.onPlaybackFinished(ev),\n      );\n    }\n  }\n\n  /**\n   * Capture an audio frame for playback, frames can be pushed faster than real-time\n   */\n  async captureFrame(_frame: AudioFrame): Promise<void> {\n    if (!this._capturing) {\n      this._capturing = true;\n      this.playbackSegmentsCount++;\n    }\n  }\n\n  /**\n   * Wait for the past audio segments to finish playing out.\n   *\n   * @returns The event that was emitted when the audio finished playing out (only the last segment information)\n   */\n  async waitForPlayout(): Promise<PlaybackFinishedEvent> {\n    const target = this.playbackSegmentsCount;\n\n    while (this.playbackFinishedCount < target) {\n      await this.playbackFinishedFuture.await;\n      this.playbackFinishedFuture = new Future();\n    }\n\n    return this.lastPlaybackEvent;\n  }\n\n  /**\n   * Developers building audio sinks must call this method when a playback/segment is finished.\n   * Segments are segmented by calls to flush() or clearBuffer()\n   */\n  onPlaybackFinished(options: PlaybackFinishedEvent) {\n    if (this.playbackFinishedCount >= this.playbackSegmentsCount) {\n      this.logger.warn('playback_finished called more times than playback segments were captured');\n      return;\n    }\n\n    this.lastPlaybackEvent = options;\n    this.playbackFinishedCount++;\n    this.playbackFinishedFuture.resolve();\n    this.emit(AudioOutput.EVENT_PLAYBACK_FINISHED, options);\n  }\n\n  flush(): void {\n    this._capturing = false;\n  }\n\n  /**\n   * Clear the buffer, stopping playback immediately\n   */\n  abstract clearBuffer(): void;\n\n  onAttached(): void {\n    if (this.nextInChain) {\n      this.nextInChain.onAttached();\n    }\n  }\n\n  onDetached(): void {\n    if (this.nextInChain) {\n      this.nextInChain.onDetached();\n    }\n  }\n}\n\nexport interface PlaybackFinishedEvent {\n  // How much of the audio was played back\n  playbackPosition: number;\n  // Interrupted is True if playback was interrupted (clearBuffer() was called)\n  interrupted: boolean;\n  // Transcript synced with playback; may be partial if the audio was interrupted\n  // When null, the transcript is not synchronized with the playback\n  synchronizedTranscript?: string;\n}\n\nexport abstract class TextOutput {\n  constructor(protected readonly nextInChain?: TextOutput) {}\n\n  /**\n   * Capture a text segment (Used by the output of LLM nodes)\n   */\n  abstract captureText(text: string): Promise<void>;\n\n  /**\n   * Mark the current text segment as complete (e.g LLM generation is complete)\n   */\n  abstract flush(): void;\n\n  onAttached(): void {\n    if (this.nextInChain) {\n      this.nextInChain.onAttached();\n    }\n  }\n\n  onDetached(): void {\n    if (this.nextInChain) {\n      this.nextInChain.onDetached();\n    }\n  }\n}\n\nexport class AgentInput {\n  private _audioStream: AudioInput | null = null;\n  // enabled by default\n  private _audioEnabled: boolean = true;\n\n  constructor(private readonly audioChanged: () => void) {}\n\n  setAudioEnabled(enable: boolean): void {\n    if (enable === this._audioEnabled) {\n      return;\n    }\n\n    this._audioEnabled = enable;\n\n    if (!this._audioStream) {\n      return;\n    }\n\n    if (enable) {\n      this._audioStream.onAttached();\n    } else {\n      this._audioStream.onDetached();\n    }\n  }\n\n  get audioEnabled(): boolean {\n    return this._audioEnabled;\n  }\n\n  get audio(): AudioInput | null {\n    return this._audioStream;\n  }\n\n  set audio(stream: AudioInput | null) {\n    this._audioStream = stream;\n    this.audioChanged();\n  }\n}\n\nexport class AgentOutput {\n  private _audioSink: AudioOutput | null = null;\n  private _transcriptionSink: TextOutput | null = null;\n  private _audioEnabled: boolean = true;\n  private _transcriptionEnabled: boolean = true;\n\n  constructor(\n    private readonly audioChanged: () => void,\n    private readonly transcriptionChanged: () => void,\n  ) {}\n\n  setAudioEnabled(enabled: boolean): void {\n    if (enabled === this._audioEnabled) {\n      return;\n    }\n\n    this._audioEnabled = enabled;\n\n    if (!this._audioSink) {\n      return;\n    }\n\n    if (enabled) {\n      this._audioSink.onAttached();\n    } else {\n      this._audioSink.onDetached();\n    }\n  }\n\n  setTranscriptionEnabled(enabled: boolean): void {\n    if (enabled === this._transcriptionEnabled) {\n      return;\n    }\n\n    this._transcriptionEnabled = enabled;\n\n    if (!this._transcriptionSink) {\n      return;\n    }\n\n    if (enabled) {\n      this._transcriptionSink.onAttached();\n    } else {\n      this._transcriptionSink.onDetached();\n    }\n  }\n\n  get audioEnabled(): boolean {\n    return this._audioEnabled;\n  }\n\n  get transcriptionEnabled(): boolean {\n    return this._transcriptionEnabled;\n  }\n\n  get audio(): AudioOutput | null {\n    return this._audioSink;\n  }\n\n  set audio(sink: AudioOutput | null) {\n    if (sink === this._audioSink) {\n      return;\n    }\n\n    if (this._audioSink) {\n      this._audioSink.onDetached();\n    }\n\n    this._audioSink = sink;\n    this.audioChanged();\n\n    if (this._audioSink) {\n      this._audioSink.onAttached();\n    }\n  }\n\n  get transcription(): TextOutput | null {\n    return this._transcriptionSink;\n  }\n\n  set transcription(sink: TextOutput | null) {\n    if (sink === this._transcriptionSink) {\n      return;\n    }\n\n    if (this._transcriptionSink) {\n      this._transcriptionSink.onDetached();\n    }\n\n    this._transcriptionSink = sink;\n    this.transcriptionChanged();\n\n    if (this._transcriptionSink) {\n      this._transcriptionSink.onAttached();\n    }\n  }\n}\n"],"mappings":"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","names":[]}
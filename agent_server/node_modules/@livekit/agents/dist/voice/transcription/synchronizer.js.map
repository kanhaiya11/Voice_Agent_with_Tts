{"version":3,"sources":["../../../src/voice/transcription/synchronizer.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport type { ReadableStream, WritableStreamDefaultWriter } from 'node:stream/web';\nimport { log } from '../../log.js';\nimport { IdentityTransform } from '../../stream/identity_transform.js';\nimport type { SentenceStream, SentenceTokenizer } from '../../tokenize/index.js';\nimport { basic } from '../../tokenize/index.js';\nimport { Future, Task, delay } from '../../utils.js';\nimport { AudioOutput, type PlaybackFinishedEvent, TextOutput } from '../io.js';\n\nconst STANDARD_SPEECH_RATE = 3.83; // hyphens (syllables) per second\n\ninterface TextSyncOptions {\n  speed: number;\n  hyphenateWord: (word: string) => string[];\n  splitWords: (words: string) => [string, number, number][];\n  sentenceTokenizer: SentenceTokenizer;\n}\n\ninterface TextData {\n  sentenceStream: SentenceStream;\n  pushedText: string;\n  done: boolean;\n  forwardedHyphens: number;\n  forwardedText: string;\n}\n\ninterface AudioData {\n  pushedDuration: number;\n  done: boolean;\n}\n\nclass SegmentSynchronizerImpl {\n  private textData: TextData;\n  private audioData: AudioData;\n  private speed: number;\n  private outputStream: IdentityTransform<string>;\n  private outputStreamWriter: WritableStreamDefaultWriter<string>;\n  private captureTask: Promise<void>;\n  private startWallTime?: number;\n\n  private startFuture: Future = new Future();\n  private closedFuture: Future = new Future();\n  private playbackCompleted: boolean = false;\n\n  private logger = log();\n\n  constructor(\n    private readonly options: TextSyncOptions,\n    private readonly nextInChain: TextOutput,\n  ) {\n    this.speed = options.speed * STANDARD_SPEECH_RATE; // hyphens per second\n    this.textData = {\n      sentenceStream: options.sentenceTokenizer.stream(),\n      pushedText: '',\n      done: false,\n      forwardedHyphens: 0,\n      forwardedText: '',\n    };\n    this.audioData = {\n      pushedDuration: 0,\n      done: false,\n    };\n    this.outputStream = new IdentityTransform();\n    this.outputStreamWriter = this.outputStream.writable.getWriter();\n\n    this.mainTask()\n      .then(() => {\n        this.outputStreamWriter.close();\n      })\n      .catch((error) => {\n        this.logger.error({ error }, 'mainTask SegmentSynchronizerImpl');\n      });\n    this.captureTask = this.captureTaskImpl();\n  }\n\n  get closed() {\n    return this.closedFuture.done;\n  }\n\n  get audioInputEnded() {\n    return this.audioData.done;\n  }\n\n  get textInputEnded() {\n    return this.textData.done;\n  }\n\n  get readable(): ReadableStream<string> {\n    return this.outputStream.readable;\n  }\n\n  pushAudio(frame: AudioFrame) {\n    if (this.closed) {\n      this.logger.warn('SegmentSynchronizerImpl.pushAudio called after close');\n      return;\n    }\n    // TODO(AJS-102): use frame.durationMs once available in rtc-node\n    const frameDuration = frame.samplesPerChannel / frame.sampleRate;\n\n    if (!this.startWallTime && frameDuration > 0) {\n      this.startWallTime = Date.now();\n      this.startFuture.resolve();\n    }\n\n    this.audioData.pushedDuration += frameDuration;\n  }\n\n  endAudioInput() {\n    if (this.closed) {\n      this.logger.warn('SegmentSynchronizerImpl.endAudioInput called after close');\n      return;\n    }\n\n    this.audioData.done = true;\n  }\n\n  pushText(text: string) {\n    if (this.closed) {\n      this.logger.warn('SegmentSynchronizerImpl.pushText called after close');\n      return;\n    }\n\n    this.textData.sentenceStream.pushText(text);\n    this.textData.pushedText += text;\n  }\n\n  endTextInput() {\n    if (this.closed) {\n      this.logger.warn('SegmentSynchronizerImpl.endTextInput called after close');\n      return;\n    }\n\n    this.textData.done = true;\n    this.textData.sentenceStream.endInput();\n  }\n\n  markPlaybackFinished(_playbackPosition: number, interrupted: boolean) {\n    if (this.closed) {\n      this.logger.warn('SegmentSynchronizerImpl.markPlaybackFinished called after close');\n      return;\n    }\n\n    if (!this.textData.done || !this.audioData.done) {\n      this.logger.warn(\n        { textDone: this.textData.done, audioDone: this.audioData.done },\n        'SegmentSynchronizerImpl.markPlaybackFinished called before text/audio input is done',\n      );\n      return;\n    }\n\n    if (!interrupted) {\n      this.playbackCompleted = true;\n    }\n  }\n\n  get synchronizedTranscript(): string {\n    if (this.playbackCompleted) {\n      return this.textData.pushedText;\n    }\n    return this.textData.forwardedText;\n  }\n\n  private async captureTaskImpl() {\n    // Don't use a for-await loop here, because exiting the loop will close the writer in the\n    // outputStream, which will cause an error in the mainTask.then method.\n    const reader = this.outputStream.readable.getReader();\n    while (true) {\n      const { done, value: text } = await reader.read();\n      if (done) {\n        break;\n      }\n      this.textData.forwardedText += text;\n      await this.nextInChain.captureText(text);\n    }\n    reader.releaseLock();\n    this.nextInChain.flush();\n  }\n\n  private async mainTask(): Promise<void> {\n    await this.startFuture.await;\n\n    if (this.closed && !this.playbackCompleted) {\n      return;\n    }\n\n    if (!this.startWallTime) {\n      throw new Error('startWallTime is not set when starting SegmentSynchronizerImpl.mainTask');\n    }\n\n    for await (const textSegment of this.textData.sentenceStream) {\n      const sentence = textSegment.token;\n\n      let textCursor = 0;\n      if (this.closed && !this.playbackCompleted) {\n        return;\n      }\n\n      for (const [word, _, endPos] of this.options.splitWords(sentence)) {\n        if (this.closed && !this.playbackCompleted) {\n          return;\n        }\n\n        if (this.playbackCompleted) {\n          this.outputStreamWriter.write(sentence.slice(textCursor, endPos));\n          textCursor = endPos;\n          continue;\n        }\n\n        const wordHphens = this.options.hyphenateWord(word).length;\n        const elapsedSeconds = (Date.now() - this.startWallTime) / 1000;\n        const targetHyphens = elapsedSeconds * this.options.speed;\n        const hyphensBehind = Math.max(0, targetHyphens - this.textData.forwardedHyphens);\n        let delay = Math.max(0, wordHphens - hyphensBehind) / this.speed;\n\n        if (this.playbackCompleted) {\n          delay = 0;\n        }\n\n        await this.sleepIfNotClosed(delay / 2);\n        this.outputStreamWriter.write(sentence.slice(textCursor, endPos));\n        await this.sleepIfNotClosed(delay / 2);\n\n        this.textData.forwardedHyphens += wordHphens;\n        textCursor = endPos;\n      }\n\n      if (textCursor < sentence.length) {\n        const remaining = sentence.slice(textCursor);\n        this.outputStreamWriter.write(remaining);\n      }\n    }\n  }\n\n  private async sleepIfNotClosed(sleepTimeSeconds: number) {\n    if (this.closed) {\n      return;\n    }\n    await delay(sleepTimeSeconds * 1000);\n  }\n\n  async close(): Promise<void> {\n    if (this.closed) {\n      return;\n    }\n    this.closedFuture.resolve();\n    this.startFuture.resolve(); // avoid deadlock of mainTaskImpl in case it never started\n    this.textData.sentenceStream.close();\n    await this.captureTask;\n  }\n}\n\nexport interface TranscriptionSynchronizerOptions {\n  speed: number;\n  hyphenateWord: (word: string) => string[];\n  splitWords: (words: string) => [string, number, number][];\n  sentenceTokenizer: SentenceTokenizer;\n}\n\nexport const defaultTextSyncOptions: TranscriptionSynchronizerOptions = {\n  speed: 1,\n  hyphenateWord: basic.hyphenateWord,\n  splitWords: basic.splitWords,\n  sentenceTokenizer: new basic.SentenceTokenizer({\n    retainFormat: true,\n  }),\n};\n\nexport class TranscriptionSynchronizer {\n  readonly audioOutput: SyncedAudioOutput;\n  readonly textOutput: SyncedTextOutput;\n\n  private options: TextSyncOptions;\n  private rotateSegmentTask: Task<void>;\n  private _enabled: boolean = true;\n  private closed: boolean = false;\n\n  /** @internal */\n  _impl: SegmentSynchronizerImpl;\n\n  private logger = log();\n\n  constructor(\n    nextInChainAudio: AudioOutput,\n    nextInChainText: TextOutput,\n    options: TranscriptionSynchronizerOptions = defaultTextSyncOptions,\n  ) {\n    this.audioOutput = new SyncedAudioOutput(this, nextInChainAudio);\n    this.textOutput = new SyncedTextOutput(this, nextInChainText);\n    this.options = {\n      speed: options.speed,\n      hyphenateWord: options.hyphenateWord,\n      splitWords: options.splitWords,\n      sentenceTokenizer: options.sentenceTokenizer,\n    };\n\n    // initial segment/first segment, recreated for each new segment\n    this._impl = new SegmentSynchronizerImpl(this.options, nextInChainText);\n    this.rotateSegmentTask = Task.from((controller) =>\n      this.rotateSegmentTaskImpl(controller.signal),\n    );\n  }\n\n  get enabled(): boolean {\n    return this._enabled;\n  }\n\n  set enabled(enabled: boolean) {\n    if (this._enabled === enabled) {\n      return;\n    }\n\n    this._enabled = enabled;\n    this.rotateSegment();\n  }\n\n  rotateSegment() {\n    if (this.closed) {\n      return;\n    }\n\n    if (!this.rotateSegmentTask.done) {\n      this.logger.warn('rotateSegment called while previous segment is still being rotated');\n    }\n    this.rotateSegmentTask = Task.from((controller) =>\n      this.rotateSegmentTaskImpl(controller.signal, this.rotateSegmentTask),\n    );\n  }\n\n  async close(): Promise<void> {\n    this.closed = true;\n    await this.rotateSegmentTask.cancelAndWait();\n    await this._impl.close();\n  }\n\n  async barrier(): Promise<void> {\n    if (this.rotateSegmentTask.done) {\n      return;\n    }\n    await this.rotateSegmentTask.result;\n  }\n\n  private async rotateSegmentTaskImpl(abort: AbortSignal, oldTask?: Task<void>) {\n    if (oldTask) {\n      await oldTask.result;\n    }\n\n    if (abort.aborted) {\n      return;\n    }\n    await this._impl.close();\n    this._impl = new SegmentSynchronizerImpl(this.options, this.textOutput.nextInChain);\n  }\n}\n\nclass SyncedAudioOutput extends AudioOutput {\n  private pushedDuration: number = 0.0;\n\n  constructor(\n    public synchronizer: TranscriptionSynchronizer,\n    private nextInChainAudio: AudioOutput,\n  ) {\n    super(nextInChainAudio.sampleRate, nextInChainAudio);\n  }\n\n  async captureFrame(frame: AudioFrame): Promise<void> {\n    // using barrier() on capture should be sufficient, flush() must not be called if\n    // capture_frame isn't completed\n    await this.synchronizer.barrier();\n\n    await super.captureFrame(frame);\n    await this.nextInChainAudio.captureFrame(frame); // passthrough audio\n\n    // TODO(AJS-102): use frame.durationMs once available in rtc-node\n    this.pushedDuration += frame.samplesPerChannel / frame.sampleRate;\n\n    if (!this.synchronizer.enabled) {\n      return;\n    }\n\n    if (this.synchronizer._impl.audioInputEnded) {\n      this.logger.warn(\n        'SegmentSynchronizerImpl audio marked as ended in capture audio, rotating segment',\n      );\n      this.synchronizer.rotateSegment();\n      await this.synchronizer.barrier();\n    }\n    this.synchronizer._impl.pushAudio(frame);\n  }\n\n  flush() {\n    super.flush();\n    this.nextInChainAudio.flush();\n\n    if (!this.synchronizer.enabled) {\n      return;\n    }\n\n    if (!this.pushedDuration) {\n      // in case there is no audio after the text was pushed, rotate the segment\n      this.synchronizer.rotateSegment();\n      return;\n    }\n\n    this.synchronizer._impl.endAudioInput();\n  }\n\n  clearBuffer() {\n    this.nextInChainAudio.clearBuffer();\n  }\n\n  // this is going to be automatically called by the next_in_chain\n  onPlaybackFinished(ev: PlaybackFinishedEvent) {\n    if (!this.synchronizer.enabled) {\n      super.onPlaybackFinished(ev);\n      return;\n    }\n\n    this.synchronizer._impl.markPlaybackFinished(ev.playbackPosition, ev.interrupted);\n    super.onPlaybackFinished({\n      playbackPosition: ev.playbackPosition,\n      interrupted: ev.interrupted,\n      synchronizedTranscript: this.synchronizer._impl.synchronizedTranscript,\n    });\n\n    this.synchronizer.rotateSegment();\n    this.pushedDuration = 0.0;\n  }\n}\n\nclass SyncedTextOutput extends TextOutput {\n  private capturing: boolean = false;\n  private logger = log();\n\n  constructor(\n    private readonly synchronizer: TranscriptionSynchronizer,\n    public readonly nextInChain: TextOutput,\n  ) {\n    super(nextInChain);\n  }\n\n  async captureText(text: string): Promise<void> {\n    await this.synchronizer.barrier();\n\n    if (!this.synchronizer.enabled) {\n      // pass through to the next in chain\n      await this.nextInChain.captureText(text);\n      return;\n    }\n\n    this.capturing = true;\n    if (this.synchronizer._impl.textInputEnded) {\n      this.logger.warn(\n        'SegmentSynchronizerImpl text marked as ended in capture text, rotating segment',\n      );\n      this.synchronizer.rotateSegment();\n      await this.synchronizer.barrier();\n    }\n    this.synchronizer._impl.pushText(text);\n  }\n\n  flush() {\n    if (!this.synchronizer.enabled) {\n      this.nextInChain.flush(); // passthrough text if the synchronizer is disabled\n      return;\n    }\n\n    if (!this.capturing) {\n      return;\n    }\n\n    this.capturing = false;\n    this.synchronizer._impl.endTextInput();\n  }\n}\n"],"mappings":"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","names":["delay"]}
{"version":3,"sources":["../../src/voice/agent.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { AsyncLocalStorage } from 'node:async_hooks';\nimport { ReadableStream } from 'node:stream/web';\nimport {\n  LLM as InferenceLLM,\n  STT as InferenceSTT,\n  TTS as InferenceTTS,\n  type LLMModels,\n  type STTModelString,\n  type TTSModelString,\n} from '../inference/index.js';\nimport { ReadonlyChatContext } from '../llm/chat_context.js';\nimport type { ChatMessage, FunctionCall, RealtimeModel } from '../llm/index.js';\nimport {\n  type ChatChunk,\n  ChatContext,\n  LLM,\n  type ToolChoice,\n  type ToolContext,\n} from '../llm/index.js';\nimport type { STT, SpeechEvent } from '../stt/index.js';\nimport { StreamAdapter as STTStreamAdapter } from '../stt/index.js';\nimport { SentenceTokenizer as BasicSentenceTokenizer } from '../tokenize/basic/index.js';\nimport type { TTS } from '../tts/index.js';\nimport { SynthesizeStream, StreamAdapter as TTSStreamAdapter } from '../tts/index.js';\nimport type { VAD } from '../vad.js';\nimport type { AgentActivity } from './agent_activity.js';\nimport type { AgentSession, TurnDetectionMode } from './agent_session.js';\n\nexport const asyncLocalStorage = new AsyncLocalStorage<{ functionCall?: FunctionCall }>();\nexport const STOP_RESPONSE_SYMBOL = Symbol('StopResponse');\n\nexport class StopResponse extends Error {\n  constructor() {\n    super();\n    this.name = 'StopResponse';\n\n    Object.defineProperty(this, STOP_RESPONSE_SYMBOL, {\n      value: true,\n    });\n  }\n}\n\nexport function isStopResponse(value: unknown): value is StopResponse {\n  return (\n    value !== undefined &&\n    value !== null &&\n    typeof value === 'object' &&\n    STOP_RESPONSE_SYMBOL in value\n  );\n}\n\nexport interface ModelSettings {\n  /** The tool choice to use when calling the LLM. */\n  toolChoice?: ToolChoice;\n}\n\nexport interface AgentOptions<UserData> {\n  instructions: string;\n  chatCtx?: ChatContext;\n  tools?: ToolContext<UserData>;\n  turnDetection?: TurnDetectionMode;\n  stt?: STT | STTModelString;\n  vad?: VAD;\n  llm?: LLM | RealtimeModel | LLMModels;\n  tts?: TTS | TTSModelString;\n  allowInterruptions?: boolean;\n  minConsecutiveSpeechDelay?: number;\n}\n\nexport class Agent<UserData = any> {\n  private turnDetection?: TurnDetectionMode;\n  private _stt?: STT;\n  private _vad?: VAD;\n  private _llm?: LLM | RealtimeModel;\n  private _tts?: TTS;\n\n  /** @internal */\n  _agentActivity?: AgentActivity;\n\n  /** @internal */\n  _chatCtx: ChatContext;\n\n  /** @internal */\n  _instructions: string;\n\n  /** @internal */\n  _tools?: ToolContext<UserData>;\n\n  constructor({\n    instructions,\n    chatCtx,\n    tools,\n    turnDetection,\n    stt,\n    vad,\n    llm,\n    tts,\n  }: AgentOptions<UserData>) {\n    this._instructions = instructions;\n    this._tools = { ...tools };\n    this._chatCtx = chatCtx\n      ? chatCtx.copy({\n          toolCtx: this._tools,\n        })\n      : ChatContext.empty();\n\n    this.turnDetection = turnDetection;\n    this._vad = vad;\n\n    if (typeof stt === 'string') {\n      this._stt = InferenceSTT.fromModelString(stt);\n    } else {\n      this._stt = stt;\n    }\n\n    if (typeof llm === 'string') {\n      this._llm = InferenceLLM.fromModelString(llm);\n    } else {\n      this._llm = llm;\n    }\n\n    if (typeof tts === 'string') {\n      this._tts = InferenceTTS.fromModelString(tts);\n    } else {\n      this._tts = tts;\n    }\n\n    this._agentActivity = undefined;\n  }\n\n  get vad(): VAD | undefined {\n    return this._vad;\n  }\n\n  get stt(): STT | undefined {\n    return this._stt;\n  }\n\n  get llm(): LLM | RealtimeModel | undefined {\n    return this._llm;\n  }\n\n  get tts(): TTS | undefined {\n    return this._tts;\n  }\n\n  get chatCtx(): ReadonlyChatContext {\n    return new ReadonlyChatContext(this._chatCtx.items);\n  }\n\n  get instructions(): string {\n    return this._instructions;\n  }\n\n  get toolCtx(): ToolContext<UserData> {\n    return { ...this._tools };\n  }\n\n  get session(): AgentSession<UserData> {\n    return this.getActivityOrThrow().agentSession as AgentSession<UserData>;\n  }\n\n  async onEnter(): Promise<void> {}\n\n  async onExit(): Promise<void> {}\n\n  async transcriptionNode(\n    text: ReadableStream<string>,\n    modelSettings: ModelSettings,\n  ): Promise<ReadableStream<string> | null> {\n    return Agent.default.transcriptionNode(this, text, modelSettings);\n  }\n\n  async onUserTurnCompleted(_chatCtx: ChatContext, _newMessage: ChatMessage): Promise<void> {}\n\n  async sttNode(\n    audio: ReadableStream<AudioFrame>,\n    modelSettings: ModelSettings,\n  ): Promise<ReadableStream<SpeechEvent | string> | null> {\n    return Agent.default.sttNode(this, audio, modelSettings);\n  }\n\n  async llmNode(\n    chatCtx: ChatContext,\n    toolCtx: ToolContext,\n    modelSettings: ModelSettings,\n  ): Promise<ReadableStream<ChatChunk | string> | null> {\n    return Agent.default.llmNode(this, chatCtx, toolCtx, modelSettings);\n  }\n\n  async ttsNode(\n    text: ReadableStream<string>,\n    modelSettings: ModelSettings,\n  ): Promise<ReadableStream<AudioFrame> | null> {\n    return Agent.default.ttsNode(this, text, modelSettings);\n  }\n\n  async realtimeAudioOutputNode(\n    audio: ReadableStream<AudioFrame>,\n    modelSettings: ModelSettings,\n  ): Promise<ReadableStream<AudioFrame> | null> {\n    return Agent.default.realtimeAudioOutputNode(this, audio, modelSettings);\n  }\n\n  // realtime_audio_output_node\n\n  getActivityOrThrow(): AgentActivity {\n    if (!this._agentActivity) {\n      throw new Error('Agent activity not found');\n    }\n    return this._agentActivity;\n  }\n\n  async updateChatCtx(chatCtx: ChatContext): Promise<void> {\n    if (!this._agentActivity) {\n      this._chatCtx = chatCtx.copy({ toolCtx: this.toolCtx });\n      return;\n    }\n\n    this._agentActivity.updateChatCtx(chatCtx);\n  }\n\n  static default = {\n    async sttNode(\n      agent: Agent,\n      audio: ReadableStream<AudioFrame>,\n      _modelSettings: ModelSettings,\n    ): Promise<ReadableStream<SpeechEvent | string> | null> {\n      const activity = agent.getActivityOrThrow();\n      if (!activity.stt) {\n        throw new Error('sttNode called but no STT node is available');\n      }\n\n      let wrapped_stt = activity.stt;\n\n      if (!wrapped_stt.capabilities.streaming) {\n        if (!agent.vad) {\n          throw new Error(\n            'STT does not support streaming, add a VAD to the AgentTask/VoiceAgent to enable streaming',\n          );\n        }\n        wrapped_stt = new STTStreamAdapter(wrapped_stt, agent.vad);\n      }\n\n      const stream = wrapped_stt.stream();\n      stream.updateInputStream(audio);\n\n      return new ReadableStream({\n        async start(controller) {\n          for await (const event of stream) {\n            controller.enqueue(event);\n          }\n          controller.close();\n        },\n        cancel() {\n          stream.detachInputStream();\n          stream.close();\n        },\n      });\n    },\n\n    async llmNode(\n      agent: Agent,\n      chatCtx: ChatContext,\n      toolCtx: ToolContext,\n      modelSettings: ModelSettings,\n    ): Promise<ReadableStream<ChatChunk | string> | null> {\n      const activity = agent.getActivityOrThrow();\n      if (!activity.llm) {\n        throw new Error('llmNode called but no LLM node is available');\n      }\n\n      if (!(activity.llm instanceof LLM)) {\n        throw new Error(\n          'llmNode should only be used with LLM (non-multimodal/realtime APIs) nodes',\n        );\n      }\n\n      // TODO(brian): make parallelToolCalls configurable\n      const { toolChoice } = modelSettings;\n\n      const stream = activity.llm.chat({\n        chatCtx,\n        toolCtx,\n        toolChoice,\n        parallelToolCalls: true,\n      });\n      return new ReadableStream({\n        async start(controller) {\n          for await (const chunk of stream) {\n            controller.enqueue(chunk);\n          }\n          controller.close();\n        },\n        cancel() {\n          stream.close();\n        },\n      });\n    },\n\n    async ttsNode(\n      agent: Agent,\n      text: ReadableStream<string>,\n      _modelSettings: ModelSettings,\n    ): Promise<ReadableStream<AudioFrame> | null> {\n      const activity = agent.getActivityOrThrow();\n      if (!activity.tts) {\n        throw new Error('ttsNode called but no TTS node is available');\n      }\n\n      let wrapped_tts = activity.tts;\n\n      if (!activity.tts.capabilities.streaming) {\n        wrapped_tts = new TTSStreamAdapter(wrapped_tts, new BasicSentenceTokenizer());\n      }\n\n      const stream = wrapped_tts.stream();\n      stream.updateInputStream(text);\n\n      return new ReadableStream({\n        async start(controller) {\n          for await (const chunk of stream) {\n            if (chunk === SynthesizeStream.END_OF_STREAM) {\n              break;\n            }\n            controller.enqueue(chunk.frame);\n          }\n          controller.close();\n        },\n        cancel() {\n          stream.close();\n        },\n      });\n    },\n\n    async transcriptionNode(\n      agent: Agent,\n      text: ReadableStream<string>,\n      _modelSettings: ModelSettings,\n    ): Promise<ReadableStream<string> | null> {\n      return text;\n    },\n\n    async realtimeAudioOutputNode(\n      _agent: Agent,\n      audio: ReadableStream<AudioFrame>,\n      _modelSettings: ModelSettings,\n    ): Promise<ReadableStream<AudioFrame> | null> {\n      return audio;\n    },\n  };\n}\n"],"mappings":"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","names":["InferenceSTT","InferenceLLM","InferenceTTS","STTStreamAdapter","TTSStreamAdapter","BasicSentenceTokenizer"]}
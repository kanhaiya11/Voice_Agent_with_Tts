{"version":3,"sources":["../src/utils.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type {\n  ParticipantKind,\n  RemoteParticipant,\n  RemoteTrackPublication,\n  Room,\n  TrackKind,\n} from '@livekit/rtc-node';\nimport { AudioFrame, AudioResampler, RoomEvent } from '@livekit/rtc-node';\nimport { EventEmitter, once } from 'node:events';\nimport type { ReadableStream } from 'node:stream/web';\nimport { TransformStream, type TransformStreamDefaultController } from 'node:stream/web';\nimport { v4 as uuidv4 } from 'uuid';\nimport { log } from './log.js';\n\n/** Union of a single and a list of {@link AudioFrame}s */\nexport type AudioBuffer = AudioFrame[] | AudioFrame;\n\nexport const noop = () => {};\n\nexport const isPending = async (promise: Promise<unknown>): Promise<boolean> => {\n  const sentinel = Symbol('sentinel');\n  const result = await Promise.race([promise, Promise.resolve(sentinel)]);\n  return result === sentinel;\n};\n\n/**\n * Merge one or more {@link AudioFrame}s into a single one.\n *\n * @param buffer - Either an {@link AudioFrame} or a list thereof\n * @throws\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n * | TypeError} if sample rate or channel count are mismatched\n */\nexport const mergeFrames = (buffer: AudioBuffer): AudioFrame => {\n  if (Array.isArray(buffer)) {\n    buffer = buffer as AudioFrame[];\n    if (buffer.length == 0) {\n      throw new TypeError('buffer is empty');\n    }\n\n    const sampleRate = buffer[0]!.sampleRate;\n    const channels = buffer[0]!.channels;\n    let samplesPerChannel = 0;\n    let data = new Int16Array();\n\n    for (const frame of buffer) {\n      if (frame.sampleRate !== sampleRate) {\n        throw new TypeError('sample rate mismatch');\n      }\n\n      if (frame.channels !== channels) {\n        throw new TypeError('channel count mismatch');\n      }\n\n      data = new Int16Array([...data, ...frame.data]);\n      samplesPerChannel += frame.samplesPerChannel;\n    }\n\n    return new AudioFrame(data, sampleRate, channels, samplesPerChannel);\n  }\n\n  return buffer;\n};\n\n/** @internal */\nexport class Queue<T> {\n  /** @internal */\n  items: T[] = [];\n  #limit?: number;\n  #events = new EventEmitter();\n\n  constructor(limit?: number) {\n    this.#limit = limit;\n  }\n\n  async get(): Promise<T> {\n    const _get = async (): Promise<T> => {\n      if (this.items.length === 0) {\n        await once(this.#events, 'put');\n      }\n      let item = this.items.shift();\n      if (!item) {\n        item = await _get();\n      }\n      return item;\n    };\n\n    const item = _get();\n    this.#events.emit('get');\n    return item;\n  }\n\n  async put(item: T) {\n    if (this.#limit && this.items.length >= this.#limit) {\n      await once(this.#events, 'get');\n    }\n    this.items.push(item);\n    this.#events.emit('put');\n  }\n}\n\n/** @internal */\nexport class Future<T = void> {\n  #await: Promise<T>;\n  #resolvePromise!: (value: T) => void;\n  #rejectPromise!: (error: Error) => void;\n  #done: boolean = false;\n\n  constructor() {\n    this.#await = new Promise<T>((resolve, reject) => {\n      this.#resolvePromise = resolve;\n      this.#rejectPromise = reject;\n    });\n  }\n\n  get await() {\n    return this.#await;\n  }\n\n  get done() {\n    return this.#done;\n  }\n\n  resolve(value: T) {\n    this.#done = true;\n    this.#resolvePromise(value);\n  }\n\n  reject(error: Error) {\n    this.#done = true;\n    this.#rejectPromise(error);\n  }\n}\n\n/** @internal */\nexport class Event {\n  #isSet = false;\n  #waiters: Array<() => void> = [];\n\n  async wait() {\n    if (this.#isSet) return true;\n\n    let resolve: () => void = noop;\n    const waiter = new Promise<void>((r) => {\n      resolve = r;\n      this.#waiters.push(resolve);\n    });\n\n    try {\n      await waiter;\n      return true;\n    } finally {\n      const index = this.#waiters.indexOf(resolve);\n      if (index !== -1) {\n        this.#waiters.splice(index, 1);\n      }\n    }\n  }\n\n  get isSet(): boolean {\n    return this.#isSet;\n  }\n\n  set(): void {\n    if (this.#isSet) return;\n\n    this.#isSet = true;\n    this.#waiters.forEach((resolve) => resolve());\n    this.#waiters = [];\n  }\n\n  clear(): void {\n    this.#isSet = false;\n  }\n}\n\n/** @internal */\nexport class CancellablePromise<T> {\n  #promise: Promise<T>;\n  #cancelFn: () => void;\n  #isCancelled: boolean = false;\n  #error: Error | null = null;\n\n  constructor(\n    executor: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: unknown) => void,\n      onCancel: (cancelFn: () => void) => void,\n    ) => void,\n  ) {\n    let cancel: () => void;\n\n    this.#promise = new Promise<T>((resolve, reject) => {\n      executor(\n        resolve,\n        (reason) => {\n          this.#error = reason instanceof Error ? reason : new Error(String(reason));\n          reject(reason);\n        },\n        (cancelFn) => {\n          cancel = () => {\n            this.#isCancelled = true;\n            cancelFn();\n          };\n        },\n      );\n    });\n\n    this.#cancelFn = cancel!;\n  }\n\n  get isCancelled(): boolean {\n    return this.#isCancelled;\n  }\n\n  get error(): Error | null {\n    return this.#error;\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | null,\n    onrejected?: ((reason: unknown) => TResult2 | Promise<TResult2>) | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.#promise.then(onfulfilled, onrejected);\n  }\n\n  catch<TResult = never>(\n    onrejected?: ((reason: unknown) => TResult | Promise<TResult>) | null,\n  ): Promise<T | TResult> {\n    return this.#promise.catch(onrejected);\n  }\n\n  finally(onfinally?: (() => void) | null): Promise<T> {\n    return this.#promise.finally(onfinally);\n  }\n\n  cancel(): void {\n    this.#cancelFn();\n  }\n\n  static from<T>(promise: Promise<T>): CancellablePromise<T> {\n    return new CancellablePromise<T>((resolve, reject) => {\n      promise.then(resolve).catch(reject);\n    });\n  }\n}\n\n/** @internal */\nexport async function gracefullyCancel<T>(promise: CancellablePromise<T>): Promise<void> {\n  if (!promise.isCancelled) {\n    promise.cancel();\n  }\n  try {\n    await promise;\n  } catch (error) {\n    // Ignore the error, as it's expected due to cancellation\n  }\n}\n\n/** @internal */\nexport class AsyncIterableQueue<T> implements AsyncIterableIterator<T> {\n  private static readonly CLOSE_SENTINEL = Symbol('CLOSE_SENTINEL');\n  #queue = new Queue<T | typeof AsyncIterableQueue.CLOSE_SENTINEL>();\n  #closed = false;\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  put(item: T): void {\n    if (this.#closed) {\n      throw new Error('Queue is closed');\n    }\n    this.#queue.put(item);\n  }\n\n  close(): void {\n    this.#closed = true;\n    this.#queue.put(AsyncIterableQueue.CLOSE_SENTINEL);\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.#closed && this.#queue.items.length === 0) {\n      return { value: undefined, done: true };\n    }\n    const item = await this.#queue.get();\n    if (item === AsyncIterableQueue.CLOSE_SENTINEL && this.#closed) {\n      return { value: undefined, done: true };\n    }\n    return { value: item as T, done: false };\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableQueue<T> {\n    return this;\n  }\n}\n\n/** @internal */\nexport class ExpFilter {\n  #alpha: number;\n  #max?: number;\n  #filtered?: number = undefined;\n\n  constructor(alpha: number, max?: number) {\n    this.#alpha = alpha;\n    this.#max = max;\n  }\n\n  reset(alpha?: number) {\n    if (alpha) {\n      this.#alpha = alpha;\n    }\n    this.#filtered = undefined;\n  }\n\n  apply(exp: number, sample: number): number {\n    if (this.#filtered) {\n      const a = this.#alpha ** exp;\n      this.#filtered = a * this.#filtered + (1 - a) * sample;\n    } else {\n      this.#filtered = sample;\n    }\n\n    if (this.#max && this.#filtered > this.#max) {\n      this.#filtered = this.#max;\n    }\n\n    return this.#filtered;\n  }\n\n  get filtered(): number | undefined {\n    return this.#filtered;\n  }\n\n  set alpha(alpha: number) {\n    this.#alpha = alpha;\n  }\n}\n\n/** @internal */\nexport class AudioEnergyFilter {\n  #cooldownSeconds: number;\n  #cooldown: number;\n\n  constructor(cooldownSeconds = 1) {\n    this.#cooldownSeconds = cooldownSeconds;\n    this.#cooldown = cooldownSeconds;\n  }\n\n  pushFrame(frame: AudioFrame): boolean {\n    const arr = Float32Array.from(frame.data, (x) => x / 32768);\n    const rms = (arr.map((x) => x ** 2).reduce((acc, x) => acc + x) / arr.length) ** 0.5;\n    if (rms > 0.004) {\n      this.#cooldown = this.#cooldownSeconds;\n      return true;\n    }\n\n    const durationSeconds = frame.samplesPerChannel / frame.sampleRate;\n    this.#cooldown -= durationSeconds;\n    if (this.#cooldown > 0) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport const TASK_TIMEOUT_ERROR = new Error('Task cancellation timed out');\n\nexport enum TaskResult {\n  Timeout = 'timeout',\n  Completed = 'completed',\n  Aborted = 'aborted',\n}\n\n/** @internal */\n/**\n * A task that can be cancelled.\n *\n * We recommend using the `Task.from` method to create a task. When creating subtasks, pass the same controller to all subtasks.\n *\n * @example\n * ```ts\n * const parent = Task.from((controller) => {\n *   const child1 = Task.from(() => { ... }, controller);\n *   const child2 = Task.from(() => { ... }, controller);\n * });\n * parent.cancel();\n * ```\n *\n * This will cancel all subtasks when the parent is cancelled.\n *\n * @param T - The type of the task result\n */\nexport class Task<T> {\n  private resultFuture: Future<T>;\n\n  #logger = log();\n\n  constructor(\n    private readonly fn: (controller: AbortController) => Promise<T>,\n    private readonly controller: AbortController,\n    readonly name?: string,\n  ) {\n    this.resultFuture = new Future();\n    this.runTask();\n  }\n\n  /**\n   * Creates a new task from a function.\n   *\n   * @param fn - The function to run\n   * @param controller - The abort controller to use\n   * @returns A new task\n   */\n  static from<T>(\n    fn: (controller: AbortController) => Promise<T>,\n    controller?: AbortController,\n    name?: string,\n  ) {\n    const abortController = controller ?? new AbortController();\n    return new Task(fn, abortController, name);\n  }\n\n  private async runTask() {\n    const run = async () => {\n      if (this.name) {\n        this.#logger.debug(`Task.runTask: task ${this.name} started`);\n      }\n      return await this.fn(this.controller);\n    };\n\n    return run()\n      .then((value) => {\n        this.resultFuture.resolve(value);\n        return value;\n      })\n      .catch((error) => {\n        this.resultFuture.reject(error);\n      })\n      .finally(() => {\n        if (this.name) {\n          this.#logger.debug(`Task.runTask: task ${this.name} done`);\n        }\n      });\n  }\n\n  /**\n   * Cancels the task.\n   */\n  cancel() {\n    this.controller.abort();\n  }\n\n  /**\n   * Cancels the task and waits for it to complete.\n   *\n   * @param timeout - The timeout in milliseconds\n   * @returns The result status of the task (timeout, completed, aborted)\n   */\n  async cancelAndWait(timeout?: number) {\n    this.cancel();\n\n    try {\n      // Race between task completion and timeout\n      const promises = [\n        this.result\n          .then(() => TaskResult.Completed)\n          .catch((error) => {\n            if (error.name === 'AbortError') {\n              return TaskResult.Aborted;\n            }\n            throw error;\n          }),\n      ];\n\n      if (timeout) {\n        promises.push(delay(timeout).then(() => TaskResult.Timeout));\n      }\n\n      const result = await Promise.race(promises);\n\n      // Check what happened\n      if (result === TaskResult.Timeout) {\n        throw TASK_TIMEOUT_ERROR;\n      }\n\n      return result;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * The result of the task.\n   */\n  get result(): Promise<T> {\n    return this.resultFuture.await;\n  }\n\n  /**\n   * Whether the task has completed.\n   */\n  get done(): boolean {\n    return this.resultFuture.done;\n  }\n\n  addDoneCallback(callback: () => void) {\n    this.resultFuture.await.finally(callback);\n  }\n}\n\nexport async function waitFor(tasks: Task<void>[]): Promise<void> {\n  await Promise.allSettled(tasks.map((task) => task.result));\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function cancelAndWait(tasks: Task<any>[], timeout?: number): Promise<void> {\n  await Promise.allSettled(tasks.map((task) => task.cancelAndWait(timeout)));\n}\n\nexport function withResolvers<T = unknown>() {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/**\n * Generates a short UUID with a prefix. Mirrors the python agents implementation.\n *\n * @param prefix - The prefix to add to the UUID.\n * @returns A short UUID with the prefix.\n */\nexport function shortuuid(prefix: string = ''): string {\n  return `${prefix}${uuidv4().slice(0, 12)}`;\n}\n\nconst READONLY_SYMBOL = Symbol('Readonly');\n\nconst MUTATION_METHODS = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n  'fill',\n  'copyWithin',\n] as const;\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n/**\n * Creates a read-only proxy for an array.\n * @param array - The array to make read-only.\n * @param additionalErrorMessage - An additional error message to include in the error thrown when a mutation method is called.\n * @returns A read-only proxy for the array.\n */\nexport function createImmutableArray<T>(array: T[], additionalErrorMessage: string = ''): T[] {\n  return new Proxy(array, {\n    get(target, key) {\n      if (key === READONLY_SYMBOL) {\n        return true;\n      }\n\n      // Intercept mutation methods\n      if (\n        typeof key === 'string' &&\n        MUTATION_METHODS.includes(key as (typeof MUTATION_METHODS)[number])\n      ) {\n        return function () {\n          throw new TypeError(\n            `Cannot call ${key}() on a read-only array. ${additionalErrorMessage}`.trim(),\n          );\n        };\n      }\n\n      return Reflect.get(target, key);\n    },\n    set(_, prop) {\n      throw new TypeError(\n        `Cannot assign to read-only array index \"${String(prop)}\". ${additionalErrorMessage}`.trim(),\n      );\n    },\n    deleteProperty(_, prop) {\n      throw new TypeError(\n        `Cannot delete read-only array index \"${String(prop)}\". ${additionalErrorMessage}`.trim(),\n      );\n    },\n    defineProperty(_, prop) {\n      throw new TypeError(\n        `Cannot define property \"${String(prop)}\" on a read-only array. ${additionalErrorMessage}`.trim(),\n      );\n    },\n    setPrototypeOf() {\n      throw new TypeError(\n        `Cannot change prototype of a read-only array. ${additionalErrorMessage}`.trim(),\n      );\n    },\n  });\n}\n\nexport function isImmutableArray(array: unknown): boolean {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return typeof array === 'object' && !!(array as any)[READONLY_SYMBOL];\n}\n\n/**\n * Resamples an audio stream to a target sample rate.\n *\n * WARINING: The input stream will be locked until the resampled stream is closed.\n *\n * @param stream - The input stream to resample.\n * @param outputRate - The target sample rate.\n * @returns A new stream with the resampled audio.\n */\nexport function resampleStream({\n  stream,\n  outputRate,\n}: {\n  stream: ReadableStream<AudioFrame>;\n  outputRate: number;\n}): ReadableStream<AudioFrame> {\n  let resampler: AudioResampler | null = null;\n  const transformStream = new TransformStream<AudioFrame, AudioFrame>({\n    transform(chunk: AudioFrame, controller: TransformStreamDefaultController<AudioFrame>) {\n      if (!resampler) {\n        resampler = new AudioResampler(chunk.sampleRate, outputRate);\n      }\n      for (const frame of resampler.push(chunk)) {\n        controller.enqueue(frame);\n      }\n      for (const frame of resampler.flush()) {\n        controller.enqueue(frame);\n      }\n    },\n  });\n  return stream.pipeThrough(transformStream);\n}\n\nexport class InvalidErrorType extends Error {\n  readonly error: unknown;\n\n  constructor(error: unknown) {\n    super(`Expected error, got ${error} (${typeof error})`);\n    this.error = error;\n    Error.captureStackTrace(this, InvalidErrorType);\n  }\n}\n\n/**\n * In JS an error can be any arbitrary value.\n * This function converts an unknown error to an Error and stores the original value in the error object.\n *\n * @param error - The error to convert.\n * @returns An Error.\n */\nexport function toError(error: unknown): Error {\n  if (error instanceof Error) {\n    return error;\n  }\n  throw new InvalidErrorType(error);\n}\n\n/**\n * This is a hack to immitate asyncio.create_task so that\n * func will be run after the current event loop iteration.\n *\n * @param func - The function to run.\n */\nexport function startSoon(func: () => void) {\n  setTimeout(func, 0);\n}\n\nexport type DelayOptions = {\n  signal?: AbortSignal;\n};\n\n/**\n * Delay for a given number of milliseconds.\n *\n * @param ms - The number of milliseconds to delay.\n * @param options - The options for the delay.\n * @returns A promise that resolves after the delay.\n */\nexport function delay(ms: number, options: DelayOptions = {}): Promise<void> {\n  const { signal } = options;\n  if (signal?.aborted) return Promise.reject(signal.reason);\n  return new Promise((resolve, reject) => {\n    const abort = () => {\n      clearTimeout(i);\n      reject(signal?.reason);\n    };\n    const done = () => {\n      signal?.removeEventListener('abort', abort);\n      resolve();\n    };\n    const i = setTimeout(done, ms);\n    signal?.addEventListener('abort', abort, { once: true });\n  });\n}\n\n/**\n * Returns a participant that matches the given identity. If identity is None, the first\n * participant that joins the room will be returned.\n * If the participant has already joined, the function will return immediately.\n * @param room - The room to wait for a participant in.\n * @param identity - The identity of the participant to wait for.\n * @param kind - The kind of the participant to wait for.\n * @returns A promise that resolves to the participant.\n */\nexport async function waitForParticipant({\n  room,\n  identity,\n  kind,\n}: {\n  room: Room;\n  identity?: string;\n  kind?: ParticipantKind | ParticipantKind[];\n}): Promise<RemoteParticipant> {\n  if (!room.isConnected) {\n    throw new Error('Room is not connected');\n  }\n\n  const fut = new Future<RemoteParticipant>();\n\n  const kindMatch = (participant: RemoteParticipant) => {\n    if (kind === undefined) return true;\n\n    if (Array.isArray(kind)) {\n      return kind.includes(participant.kind);\n    }\n\n    return participant.kind === kind;\n  };\n\n  const onParticipantConnected = (p: RemoteParticipant) => {\n    if ((identity === undefined || p.identity === identity) && kindMatch(p)) {\n      if (!fut.done) {\n        fut.resolve(p);\n      }\n    }\n  };\n\n  room.on(RoomEvent.ParticipantConnected, onParticipantConnected);\n\n  try {\n    for (const p of room.remoteParticipants.values()) {\n      onParticipantConnected(p);\n      if (fut.done) {\n        break;\n      }\n    }\n\n    return await fut.await;\n  } finally {\n    room.off(RoomEvent.ParticipantConnected, onParticipantConnected);\n  }\n}\n\nexport async function waitForTrackPublication({\n  room,\n  identity,\n  kind,\n}: {\n  room: Room;\n  identity: string;\n  kind: TrackKind;\n}): Promise<RemoteTrackPublication> {\n  if (!room.isConnected) {\n    throw new Error('Room is not connected');\n  }\n\n  const fut = new Future<RemoteTrackPublication>();\n\n  const kindMatch = (k: TrackKind | undefined) => {\n    if (kind === undefined || kind === null) {\n      return true;\n    }\n    return k === kind;\n  };\n\n  const onTrackPublished = (\n    publication: RemoteTrackPublication,\n    participant: RemoteParticipant,\n  ) => {\n    if (fut.done) return;\n    if (\n      (identity === undefined || participant.identity === identity) &&\n      kindMatch(publication.kind)\n    ) {\n      fut.resolve(publication);\n    }\n  };\n\n  room.on(RoomEvent.TrackPublished, onTrackPublished);\n\n  try {\n    for (const p of room.remoteParticipants.values()) {\n      for (const publication of p.trackPublications.values()) {\n        onTrackPublished(publication, p);\n        if (fut.done) break;\n      }\n    }\n\n    return await fut.await;\n  } finally {\n    room.off(RoomEvent.TrackPublished, onTrackPublished);\n  }\n}\n\nexport async function waitForAbort(signal: AbortSignal) {\n  const abortFuture = new Future<void>();\n  const handler = () => {\n    abortFuture.resolve();\n    signal.removeEventListener('abort', handler);\n  };\n\n  signal.addEventListener('abort', handler, { once: true });\n  return await abortFuture.await;\n}\n"],"mappings":"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","names":["item","TaskResult","uuidv4"]}
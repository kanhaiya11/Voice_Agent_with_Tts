{"version":3,"sources":["../../src/stream/identity_transform.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { describe, expect, it } from 'vitest';\nimport { IdentityTransform } from './identity_transform.js';\n\ndescribe('IdentityTransform', () => {\n  it('should handle stream with one value', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const inputValue = 'single value';\n\n    await writer.write(inputValue);\n    await writer.close();\n\n    const result = await reader.read();\n    expect(result.done).toBe(false);\n    expect(result.value).toBe(inputValue);\n\n    const nextResult = await reader.read();\n    expect(nextResult.done).toBe(true);\n  });\n\n  it('should handle multiple values in sequence', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const inputValues = ['first', 'second', 'third'];\n\n    // Write all values\n    for (const value of inputValues) {\n      await writer.write(value);\n    }\n    await writer.close();\n\n    // Read all values\n    const results: string[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(inputValues);\n  });\n\n  it('should handle null and undefined values', async () => {\n    const transform = new IdentityTransform<string | null | undefined>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const inputValues = ['test', null, undefined, 'another'];\n\n    // Write all values\n    for (const value of inputValues) {\n      await writer.write(value);\n    }\n    await writer.close();\n\n    // Read all values\n    const results: (string | null | undefined)[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(inputValues);\n  });\n\n  it('should handle arrays', async () => {\n    const transform = new IdentityTransform<number[]>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const inputValue = [1, 2, 3, 4, 5];\n\n    await writer.write(inputValue);\n    await writer.close();\n\n    const result = await reader.read();\n\n    expect(result.done).toBe(false);\n    expect(result.value).toEqual(inputValue);\n    expect(result.value).toBe(inputValue); // Should be the same reference\n\n    const nextResult = await reader.read();\n    expect(nextResult.done).toBe(true);\n  });\n\n  it('should work with streamed data', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const testData = ['chunk1', 'chunk2', 'chunk3'];\n\n    // Write data asynchronously to simulate streaming\n    const writePromise = (async () => {\n      for (const chunk of testData) {\n        await writer.write(chunk);\n      }\n      await writer.close();\n    })();\n\n    // Read data as it comes through\n    const results: string[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    await writePromise;\n    expect(results).toEqual(testData);\n  });\n\n  it('should handle empty stream', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    // Close immediately without writing anything\n    await writer.close();\n\n    // Should immediately be done\n    const result = await reader.read();\n    expect(result.done).toBe(true);\n  });\n\n  it('should handle writer closing while reading is in progress', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const testData = ['chunk1', 'chunk2', 'chunk3'];\n    const results: string[] = [];\n\n    // Start writing some data\n    await writer.write(testData[0]);\n    await writer.write(testData[1]);\n\n    // Start reading concurrently\n    const readPromise = (async () => {\n      let result = await reader.read();\n      while (!result.done) {\n        results.push(result.value);\n        result = await reader.read();\n      }\n    })();\n\n    // Write one more chunk and then close the writer while reading\n    await writer.write(testData[2]);\n    await writer.close();\n\n    // Wait for reading to complete\n    await readPromise;\n\n    // Should have received all the data\n    expect(results).toEqual(testData);\n  });\n\n  it('should handle a pending read when the writer is closed', async () => {\n    const transform = new IdentityTransform<string>();\n    const writer = transform.writable.getWriter();\n    const reader = transform.readable.getReader();\n\n    const readPromise = reader.read();\n\n    await writer.close();\n\n    const result = await readPromise;\n    expect(result.done).toBe(true);\n    expect(result.value).toBeUndefined();\n  });\n});\n"],"mappings":"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","names":[]}
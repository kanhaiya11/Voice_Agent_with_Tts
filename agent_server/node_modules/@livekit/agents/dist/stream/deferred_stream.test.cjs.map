{"version":3,"sources":["../../src/stream/deferred_stream.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { ReadableStream } from 'node:stream/web';\nimport { describe, expect, it } from 'vitest';\nimport { delay } from '../utils.js';\nimport { DeferredReadableStream } from './deferred_stream.js';\n\ndescribe('DeferredReadableStream', () => {\n  it('should create a readable stream that can be read after setting source', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Create a source stream with test data\n    const testData = ['chunk1', 'chunk2', 'chunk3'];\n    const source = new ReadableStream<string>({\n      start(controller) {\n        for (const chunk of testData) {\n          controller.enqueue(chunk);\n        }\n        controller.close();\n      },\n    });\n\n    // Set the source\n    deferred.setSource(source);\n\n    // Read all data\n    const results: string[] = [];\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(testData);\n  });\n\n  it('should allow reading from stream before source is set', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Start reading before source is set (this should not resolve immediately)\n    const readPromise = reader.read();\n\n    // Wait a bit to ensure the read is pending\n    await delay(10);\n\n    // Now set the source\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue('test-value');\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // The read should now resolve\n    const result = await readPromise;\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('test-value');\n\n    // Next read should indicate stream completion\n    const nextResult = await reader.read();\n    expect(nextResult.done).toBe(true);\n  });\n\n  it('should throw error when trying to set source on locked stream', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    // Get a reader to lock the stream\n    const reader = deferred.stream.getReader();\n\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue('test');\n        controller.close();\n      },\n    });\n\n    const source2 = new ReadableStream({\n      start(controller) {\n        controller.enqueue('test2');\n        controller.close();\n      },\n    });\n\n    expect(() => deferred.setSource(source)).not.toThrow();\n    expect(() => deferred.setSource(source2)).toThrow('Stream source already set');\n\n    // Clean up\n    reader.releaseLock();\n  });\n\n  it('should handle multiple concurrent readers before source is set', async () => {\n    const deferred = new DeferredReadableStream<number>();\n\n    // Create multiple readers by using tee()\n    const [stream1, stream2] = deferred.stream.tee();\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n\n    // Start reading from both streams concurrently\n    const read1Promise = reader1.read();\n    const read2Promise = reader2.read();\n\n    // Wait to ensure reads are pending\n    await delay(10);\n\n    // Set source with test data\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue(42);\n        controller.enqueue(84);\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // Both readers should receive the data\n    const [result1, result2] = await Promise.all([read1Promise, read2Promise]);\n\n    expect(result1.done).toBe(false);\n    expect(result1.value).toBe(42);\n    expect(result2.done).toBe(false);\n    expect(result2.value).toBe(42);\n\n    // Read second values\n    const [second1, second2] = await Promise.all([reader1.read(), reader2.read()]);\n    expect(second1.value).toBe(84);\n    expect(second2.value).toBe(84);\n  });\n\n  it('should handle concurrent reads and writes', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Create a source that writes data over time\n    const chunks = ['a', 'b', 'c', 'd', 'e'];\n    let chunkIndex = 0;\n\n    const source = new ReadableStream({\n      start(controller) {\n        const writeNext = () => {\n          if (chunkIndex < chunks.length) {\n            controller.enqueue(chunks[chunkIndex++]);\n            setTimeout(writeNext, 5); // Write next chunk after small delay\n          } else {\n            controller.close();\n          }\n        };\n        writeNext();\n      },\n    });\n\n    // Set source and immediately start reading concurrently\n    deferred.setSource(source);\n\n    const results: string[] = [];\n    const readConcurrently = async () => {\n      let result = await reader.read();\n      while (!result.done) {\n        results.push(result.value);\n        result = await reader.read();\n      }\n    };\n\n    await readConcurrently();\n    expect(results).toEqual(chunks);\n  });\n\n  it('should handle race condition between setSource and getReader', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue('race-test');\n        controller.close();\n      },\n    });\n\n    // Race between setting source and getting reader\n    const [, reader] = await Promise.all([\n      // Set source\n      Promise.resolve().then(() => deferred.setSource(source)),\n      // Get reader\n      Promise.resolve().then(() => deferred.stream.getReader()),\n    ]);\n\n    const result = await reader.read();\n    expect(result.value).toBe('race-test');\n  });\n\n  it('should handle empty source stream', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    const emptySource = new ReadableStream({\n      start(controller) {\n        controller.close();\n      },\n    });\n\n    deferred.setSource(emptySource);\n\n    const result = await reader.read();\n    expect(result.done).toBe(true);\n  });\n\n  it('should handle source stream with errors', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    const errorSource = new ReadableStream({\n      async start(controller) {\n        controller.enqueue('before-error');\n        // Use async/await to keep the error within the test scope\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        controller.error(new Error('Source stream error'));\n      },\n    });\n\n    deferred.setSource(errorSource);\n\n    // Should read the value before error\n    const result1 = await reader.read();\n    expect(result1.value).toBe('before-error');\n\n    // Next read should throw the error\n    await expect(() => reader.read()).rejects.toThrow('Source stream error');\n  });\n\n  it('should handle multiple concurrent read operations', async () => {\n    const deferred = new DeferredReadableStream<number>();\n    const reader = deferred.stream.getReader();\n\n    // Start multiple read operations before setting source\n    const readPromises = Array.from({ length: 3 }, () => reader.read());\n\n    await delay(10);\n\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue(1);\n        controller.enqueue(2);\n        controller.enqueue(3);\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // All reads should resolve with the sequential values\n    const results = await Promise.all(readPromises);\n\n    expect(results[0]?.value).toBe(1);\n    expect(results[1]?.value).toBe(2);\n    expect(results[2]?.value).toBe(3);\n    expect(results.every((r) => !r.done)).toBe(true);\n\n    // Final read should indicate completion\n    const finalResult = await reader.read();\n    expect(finalResult.done).toBe(true);\n  });\n\n  it('should handle backpressure correctly', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    // Create a source with large chunks to test backpressure\n    const largeChunks = Array.from({ length: 1000 }, (_, i) => `chunk-${i}`);\n\n    const source = new ReadableStream({\n      start(controller) {\n        for (const chunk of largeChunks) {\n          controller.enqueue(chunk);\n        }\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    const reader = deferred.stream.getReader();\n    const results: string[] = [];\n\n    // Read all chunks\n    let result = await reader.read();\n    while (!result.done) {\n      results.push(result.value);\n      result = await reader.read();\n    }\n\n    expect(results).toEqual(largeChunks);\n  });\n\n  it('should handle concurrent setSource calls (second should fail)', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    const source1 = new ReadableStream({\n      start(controller) {\n        controller.enqueue('first');\n        controller.close();\n      },\n    });\n\n    const source2 = new ReadableStream({\n      start(controller) {\n        controller.enqueue('second');\n        controller.close();\n      },\n    });\n\n    // First setSource should succeed\n    deferred.setSource(source1);\n\n    // Second setSource should fail because stream is now locked\n    expect(() => deferred.setSource(source2)).toThrow('Stream source already set');\n\n    // Verify we get data from the first source\n    const reader = deferred.stream.getReader();\n    const result = await reader.read();\n    expect(result.value).toBe('first');\n  });\n\n  it('should handle reader release and re-acquire before source is set', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    // Get reader and immediately release it\n    const reader1 = deferred.stream.getReader();\n    reader1.releaseLock();\n\n    // Get a new reader\n    const reader2 = deferred.stream.getReader();\n\n    // Now set the source\n    const source = new ReadableStream({\n      start(controller) {\n        controller.enqueue('test-after-release');\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    const result = await reader2.read();\n    expect(result.value).toBe('test-after-release');\n  });\n\n  it('should handle type safety with different data types', async () => {\n    interface TestData {\n      id: number;\n      name: string;\n    }\n\n    const deferred = new DeferredReadableStream<TestData>();\n    const reader = deferred.stream.getReader();\n\n    const testObject: TestData = { id: 1, name: 'test' };\n\n    const source = new ReadableStream<TestData>({\n      start(controller) {\n        controller.enqueue(testObject);\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    const result = await reader.read();\n    expect(result.value).toEqual(testObject);\n    expect(result.value).toBeDefined();\n    expect(typeof result.value!.id).toBe('number');\n    expect(typeof result.value!.name).toBe('string');\n  });\n\n  it('should create a readable stream', () => {\n    const deferred = new DeferredReadableStream<string>();\n    expect(deferred.stream).toBeInstanceOf(ReadableStream);\n  });\n\n  it('should keep reader awaiting before source is set, then read after source is set', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Track if read operation is still pending\n    let readCompleted = false;\n\n    // Start reading - this should hang until source is set\n    const readPromise = reader.read().then((result) => {\n      readCompleted = true;\n      return result;\n    });\n\n    // Give some time to ensure read doesn't complete immediately\n    await delay(50);\n    expect(readCompleted).toBe(false);\n\n    // Create and set the source\n    const sourceData = ['hello', 'world'];\n    const source = new ReadableStream<string>({\n      start(controller) {\n        sourceData.forEach((chunk) => controller.enqueue(chunk));\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // Now the read should complete\n    const result = await readPromise;\n    expect(readCompleted).toBe(true);\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('hello');\n\n    // Read the second chunk\n    const result2 = await reader.read();\n    expect(result2.done).toBe(false);\n    expect(result2.value).toBe('world');\n\n    // Stream should be closed\n    const result3 = await reader.read();\n    expect(result3.done).toBe(true);\n    expect(result3.value).toBeUndefined();\n\n    reader.releaseLock();\n  });\n\n  it('should handle multiple chunks from source', async () => {\n    const deferred = new DeferredReadableStream<number>();\n    const chunks: number[] = [];\n\n    // Set up a reader that collects all chunks\n    const collectPromise = (async () => {\n      const reader = deferred.stream.getReader();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          chunks.push(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    })();\n\n    // Create a source that emits multiple chunks over time\n    const source = new ReadableStream<number>({\n      async start(controller) {\n        for (let i = 0; i < 5; i++) {\n          controller.enqueue(i);\n          await delay(10);\n        }\n        controller.close();\n      },\n    });\n\n    // Set the source\n    deferred.setSource(source);\n\n    // Wait for all chunks to be collected\n    await collectPromise;\n\n    expect(chunks).toEqual([0, 1, 2, 3, 4]);\n  });\n\n  it('should propagate errors from source to reader', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Start reading\n    const readPromise = reader.read();\n\n    // Create a source that errors\n    const errorMessage = 'Source error';\n    const source = new ReadableStream<string>({\n      async start(controller) {\n        controller.error(new Error(errorMessage));\n      },\n      cancel(reason) {\n        console.log('cancel', reason);\n      },\n    });\n\n    deferred.setSource(source);\n\n    // The read should reject with the error\n    try {\n      await readPromise;\n      expect.fail('readPromise should have rejected');\n    } catch (e: unknown) {\n      const error = e as Error;\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message).toBe('Source error');\n    }\n\n    reader.releaseLock();\n  });\n\n  it('should throw error when trying to set source twice', () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    const source1 = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue('first');\n        controller.close();\n      },\n    });\n\n    const source2 = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue('second');\n        controller.close();\n      },\n    });\n\n    // First setSource should work\n    deferred.setSource(source1);\n\n    // Second setSource should throw\n    expect(() => deferred.setSource(source2)).toThrow('Stream source already set');\n  });\n\n  it('should throw error when trying to detach source before setting it', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    // Attempting to detach source before setting it should throw\n    await expect(deferred.detachSource()).rejects.toThrow('Source not set');\n  });\n\n  it('read returns undefined as soon as reader is cancelled', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n    const readPromise = reader.read();\n\n    const source = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue('data');\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    await reader.cancel();\n\n    const result = await readPromise;\n    expect(result.done).toBe(true);\n    expect(result.value).toBeUndefined();\n\n    reader.releaseLock();\n  });\n\n  it('reads after detaching source should return undefined', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n    const readPromise = reader.read();\n\n    const source = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue('first');\n        controller.enqueue('second');\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // Detach the source\n    await deferred.detachSource();\n\n    const result = await readPromise;\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('first');\n\n    const result2 = await reader.read();\n    expect(result2.done).toBe(true);\n    expect(result2.value).toBeUndefined();\n    reader.releaseLock();\n\n    const reader2 = source.getReader();\n    const result3 = await reader2.read();\n    expect(result3.done).toBe(false);\n    expect(result3.value).toBe('second');\n\n    const result4 = await reader2.read();\n    expect(result4.done).toBe(true);\n    expect(result4.value).toBeUndefined();\n    reader.releaseLock();\n  });\n\n  it('should handle empty source stream', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n\n    // Start reading\n    const readPromise = reader.read();\n\n    // Set an empty source\n    const source = new ReadableStream<string>({\n      start(controller) {\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n\n    // Read should indicate end of stream\n    const result = await readPromise;\n    expect(result.done).toBe(true);\n    expect(result.value).toBeUndefined();\n\n    reader.releaseLock();\n  });\n\n  it('source can be set by another deferred stream after calling detach', async () => {\n    const deferred = new DeferredReadableStream<string>();\n\n    // Create a new source stream\n    const source = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue('before-cancel');\n        controller.enqueue('after-cancel');\n        controller.close();\n      },\n    });\n\n    // read first chunk\n    deferred.setSource(source);\n    const reader = deferred.stream.getReader();\n    const result = await reader.read();\n    expect(result.done).toBe(false);\n    expect(result.value).toBe('before-cancel');\n\n    const result2Promise = reader.read();\n\n    // detach the source\n    await deferred.detachSource();\n\n    // read second chunk\n    const result2 = await result2Promise;\n    expect(result2.done).toBe(true);\n    expect(result2.value).toBeUndefined();\n\n    // we manually release the lock\n    reader.releaseLock();\n\n    // create a new deferred stream and set the source\n    const deferred2 = new DeferredReadableStream<string>();\n    deferred2.setSource(source);\n    const reader2 = deferred2.stream.getReader();\n\n    // read the second chunk\n    const result3 = await reader2.read();\n    expect(result3.done).toBe(false);\n    expect(result3.value).toBe('after-cancel');\n\n    // read the third chunk\n    const result4 = await reader2.read();\n    expect(result4.done).toBe(true);\n    expect(result4.value).toBeUndefined();\n    reader2.releaseLock();\n  });\n\n  it('a non-terminating source reader releases lock after detaching', async () => {\n    const deferred = new DeferredReadableStream<string>();\n    const reader = deferred.stream.getReader();\n    const readPromise = reader.read();\n    let resumeSource = false;\n\n    const source = new ReadableStream<string>({\n      async start(controller) {\n        while (!resumeSource) await delay(10);\n\n        controller.enqueue('data');\n        controller.close();\n      },\n    });\n\n    deferred.setSource(source);\n    await deferred.detachSource();\n    await delay(100);\n\n    // read before detach should return undefined since source never resumed\n    const result = await readPromise;\n    expect(result.done).toBe(true);\n    expect(result.value).toBeUndefined();\n\n    const reader2 = source.getReader();\n    resumeSource = true;\n\n    // read after detach should return correct order of data since source resumed\n    const result2 = await reader2.read();\n    expect(result2.done).toBe(false);\n    expect(result2.value).toBe('data');\n\n    const result3 = await reader2.read();\n    expect(result3.done).toBe(true);\n    expect(result3.value).toBeUndefined();\n\n    reader2.releaseLock();\n  });\n\n  it('should transfer source between deferred streams while reading is ongoing', async () => {\n    const deferred1 = new DeferredReadableStream<string>();\n    const deferred2 = new DeferredReadableStream<string>();\n\n    // Create a source that slowly emits data\n    const source = new ReadableStream<string>({\n      async start(controller) {\n        // Emit 5 chunks with delays\n        for (let i = 0; i < 4; i++) {\n          controller.enqueue(`chunk-${i}`);\n          await delay(20); // Small delay between chunks\n        }\n        controller.close();\n      },\n    });\n\n    deferred1.setSource(source);\n    const reader1 = deferred1.stream.getReader();\n    const result1 = await reader1.read();\n    expect(result1.done).toBe(false);\n    expect(result1.value).toBe('chunk-0');\n\n    const result2 = await reader1.read();\n    expect(result2.done).toBe(false);\n    expect(result2.value).toBe('chunk-1');\n    await delay(10);\n    await deferred1.detachSource();\n\n    // reader1 now done\n    const result3 = await reader1.read();\n    expect(result3.done).toBe(true);\n    expect(result3.value).toBeUndefined();\n\n    deferred2.setSource(source);\n    const reader2 = deferred2.stream.getReader();\n    const result4 = await reader2.read();\n    expect(result4.done).toBe(false);\n    expect(result4.value).toBe('chunk-2');\n\n    const result5 = await reader2.read();\n    expect(result5.done).toBe(false);\n    expect(result5.value).toBe('chunk-3');\n\n    const result6 = await reader2.read();\n    expect(result6.done).toBe(true);\n    expect(result6.value).toBeUndefined();\n\n    reader1.releaseLock();\n    reader2.releaseLock();\n  });\n});\n"],"mappings":"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","names":["result"]}
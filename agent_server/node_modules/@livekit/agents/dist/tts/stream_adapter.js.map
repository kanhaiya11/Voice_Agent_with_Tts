{"version":3,"sources":["../../src/tts/stream_adapter.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { SentenceStream, SentenceTokenizer } from '../tokenize/index.js';\nimport { Task } from '../utils.js';\nimport type { ChunkedStream } from './tts.js';\nimport { SynthesizeStream, TTS } from './tts.js';\n\nexport class StreamAdapter extends TTS {\n  #tts: TTS;\n  #sentenceTokenizer: SentenceTokenizer;\n  label: string;\n\n  constructor(tts: TTS, sentenceTokenizer: SentenceTokenizer) {\n    super(tts.sampleRate, tts.numChannels, { streaming: true });\n    this.#tts = tts;\n    this.#sentenceTokenizer = sentenceTokenizer;\n    this.label = this.#tts.label;\n    this.label = `tts.StreamAdapter<${this.#tts.label}>`;\n\n    this.#tts.on('metrics_collected', (metrics) => {\n      this.emit('metrics_collected', metrics);\n    });\n  }\n\n  synthesize(text: string): ChunkedStream {\n    return this.#tts.synthesize(text);\n  }\n\n  stream(): StreamAdapterWrapper {\n    return new StreamAdapterWrapper(this.#tts, this.#sentenceTokenizer);\n  }\n}\n\nexport class StreamAdapterWrapper extends SynthesizeStream {\n  #tts: TTS;\n  #sentenceStream: SentenceStream;\n  label: string;\n\n  constructor(tts: TTS, sentenceTokenizer: SentenceTokenizer) {\n    super(tts);\n    this.#tts = tts;\n    this.#sentenceStream = sentenceTokenizer.stream();\n    this.label = `tts.StreamAdapterWrapper<${this.#tts.label}>`;\n  }\n\n  protected async run() {\n    const forwardInput = async () => {\n      for await (const input of this.input) {\n        if (this.abortController.signal.aborted) break;\n\n        if (input === SynthesizeStream.FLUSH_SENTINEL) {\n          this.#sentenceStream.flush();\n        } else {\n          this.#sentenceStream.pushText(input);\n        }\n      }\n      this.#sentenceStream.endInput();\n      this.#sentenceStream.close();\n    };\n\n    const synthesizeSentenceStream = async () => {\n      let task: Task<void> | undefined;\n      const tokenCompletionTasks: Task<void>[] = [];\n\n      for await (const ev of this.#sentenceStream) {\n        if (this.abortController.signal.aborted) break;\n\n        // this will enable non-blocking synthesis of the stream of tokens\n        task = Task.from(\n          (controller) => synthesize(ev.token, task, controller),\n          this.abortController,\n        );\n\n        tokenCompletionTasks.push(task);\n      }\n\n      await Promise.all(tokenCompletionTasks.map((t) => t.result));\n      this.queue.put(SynthesizeStream.END_OF_STREAM);\n    };\n\n    const synthesize = async (\n      token: string,\n      prevTask: Task<void> | undefined,\n      controller: AbortController,\n    ) => {\n      const audioStream = this.#tts.synthesize(token);\n\n      // wait for previous audio transcription to complete before starting\n      // to queuing audio frames of the current token\n      await prevTask?.result;\n      if (controller.signal.aborted) return;\n\n      for await (const audio of audioStream) {\n        if (controller.signal.aborted) break;\n        this.queue.put(audio);\n      }\n    };\n\n    await Promise.all([forwardInput(), synthesizeSentenceStream()]);\n  }\n}\n"],"mappings":"AAIA,SAAS,YAAY;AAErB,SAAS,kBAAkB,WAAW;AAE/B,MAAM,sBAAsB,IAAI;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,mBAAsC;AAC1D,UAAM,IAAI,YAAY,IAAI,aAAa,EAAE,WAAW,KAAK,CAAC;AAC1D,SAAK,OAAO;AACZ,SAAK,qBAAqB;AAC1B,SAAK,QAAQ,KAAK,KAAK;AACvB,SAAK,QAAQ,qBAAqB,KAAK,KAAK,KAAK;AAEjD,SAAK,KAAK,GAAG,qBAAqB,CAAC,YAAY;AAC7C,WAAK,KAAK,qBAAqB,OAAO;AAAA,IACxC,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,MAA6B;AACtC,WAAO,KAAK,KAAK,WAAW,IAAI;AAAA,EAClC;AAAA,EAEA,SAA+B;AAC7B,WAAO,IAAI,qBAAqB,KAAK,MAAM,KAAK,kBAAkB;AAAA,EACpE;AACF;AAEO,MAAM,6BAA6B,iBAAiB;AAAA,EACzD;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,mBAAsC;AAC1D,UAAM,GAAG;AACT,SAAK,OAAO;AACZ,SAAK,kBAAkB,kBAAkB,OAAO;AAChD,SAAK,QAAQ,4BAA4B,KAAK,KAAK,KAAK;AAAA,EAC1D;AAAA,EAEA,MAAgB,MAAM;AACpB,UAAM,eAAe,YAAY;AAC/B,uBAAiB,SAAS,KAAK,OAAO;AACpC,YAAI,KAAK,gBAAgB,OAAO,QAAS;AAEzC,YAAI,UAAU,iBAAiB,gBAAgB;AAC7C,eAAK,gBAAgB,MAAM;AAAA,QAC7B,OAAO;AACL,eAAK,gBAAgB,SAAS,KAAK;AAAA,QACrC;AAAA,MACF;AACA,WAAK,gBAAgB,SAAS;AAC9B,WAAK,gBAAgB,MAAM;AAAA,IAC7B;AAEA,UAAM,2BAA2B,YAAY;AAC3C,UAAI;AACJ,YAAM,uBAAqC,CAAC;AAE5C,uBAAiB,MAAM,KAAK,iBAAiB;AAC3C,YAAI,KAAK,gBAAgB,OAAO,QAAS;AAGzC,eAAO,KAAK;AAAA,UACV,CAAC,eAAe,WAAW,GAAG,OAAO,MAAM,UAAU;AAAA,UACrD,KAAK;AAAA,QACP;AAEA,6BAAqB,KAAK,IAAI;AAAA,MAChC;AAEA,YAAM,QAAQ,IAAI,qBAAqB,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAC3D,WAAK,MAAM,IAAI,iBAAiB,aAAa;AAAA,IAC/C;AAEA,UAAM,aAAa,OACjB,OACA,UACA,eACG;AACH,YAAM,cAAc,KAAK,KAAK,WAAW,KAAK;AAI9C,aAAM,qCAAU;AAChB,UAAI,WAAW,OAAO,QAAS;AAE/B,uBAAiB,SAAS,aAAa;AACrC,YAAI,WAAW,OAAO,QAAS;AAC/B,aAAK,MAAM,IAAI,KAAK;AAAA,MACtB;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,CAAC,aAAa,GAAG,yBAAyB,CAAC,CAAC;AAAA,EAChE;AACF;","names":[]}